var jsparams_objects = {};
var rubix_log;

try
{
	/**
	 * IE fixes
	 *
	 * Several fixes are required for IE to work properly
	 * - console.* are objects, not functions, and therefore lack apply (8, 9)
	 * -- To implement apply, bind is required, which is also lacking (at least 8)
	 * - console.debug does not exist (at least 8)
	 */

	/**
	 * Implementation of function.bind for older IEs that don't natively support it
	 * Includes support for using bind with things that should be functions but aren't
	 * (currently, console.*)
	 */
	if (!Function.prototype.bind) {
		Function.prototype.bind = function (oThis) {
			if (typeof this !== "function") {
				var console_fns = ['log','info','warn','error','assert','dir','clear','profile','profileEnd'];
				var is_console = false;
				for (var i = 0; i < console_fns.length; i++)
				{
					if (this === console[console_fns[i]])
					{
						is_console = true;
						break;
					}
				}
				if (!is_console)
				{
					// closest thing possible to the ECMAScript 5 internal IsCallable function
					throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
				}
			}
			var aArgs = Array.prototype.slice.call(arguments, 1),
			fToBind = this,
			fNOP = function () {},
			fBound = function () {
			return fToBind.apply(this instanceof fNOP && oThis
				? this
				: oThis,
				aArgs.concat(Array.prototype.slice.call(arguments)));
			};

			fNOP.prototype = this.prototype;
			fBound.prototype = new fNOP();

			return fBound;
		};
	}

	/**
	 * If we're using a browser where console.* are objects and not functions, "clone"
	 * them using .bind to create function versions supporting apply
	 */
	if (typeof console !== 'undefined' && typeof console.log == 'object') {
		var console_fns = ['log','info','warn','error','assert','dir','clear','profile','profileEnd'];
		for (var i = 0; i < console_fns.length; i++)
		{
			if (typeof Function.prototype.call !== 'undefined' && typeof Function.prototype.call.bind !== 'undefined')
			{
				console[console_fns[i]] = Function.prototype.call.bind(console[console_fns[i]], console);
			}
			else if (typeof Function.prototype.bind !== 'undefined' && typeof Function.prototype.bind.call !== 'undefined')
			{
				console[console_fns[i]] = Function.prototype.bind.call(console[console_fns[i]], console);
			}
			else
			{
				console.error("Cannot use bind to clone console.* in this browser");
			}
		}
	}

	// Fix ie8 again
	if (typeof console.debug === 'undefined')
	{
		console.debug = console.log;
	}

	/**
	 * Rubix javascript logging for modules
	 * @param  {string} module Module name for which the object is being instantiated, to track down where log messages come from
	 * @return {null}
	 */
	rubix_log = function(module)
	{
		// Configuration
		/**
		 * If true, show a timestamp with each log message since some browsers (like Chrome)
		 * don't do that on their own
		 * @type {Boolean}
		 */
		this.show_timestamp = true;

		// Passed in configuration

		/**
		 * Module name added to all log messages generated by this object
		 * @type {string}
		 */
		this.module = module;

		// Other useful vars

		/**
		 * Log message queue.  Used in browsers where console and console.* might not
		 * always exist (like IE) to buffer messages until that object does exist
		 * @type {Array}
		 */
		this.queue = [];

		/**
		 * Set automatically, if false no log messages are shown (for production)
		 * @type {Boolean}
		 */
		this.is_enabled = undefined;

		// Override our defaults with the real defaults!
		for (var prop in rubix_log._defaults)
		{
			if (rubix_log._defaults.hasOwnProperty(prop))
			{
				this[prop] = rubix_log._defaults[prop];
			}
		}

		rubix_log._instances.push(this);
		this.enable = rubix_log.enable;
		this.is_enabled = rubix_log.can_enable;

		// Utility functions

		/**
		 * Pad a string to a specified length with a pad character
		 * @param  {string} string Input string to be padded
		 * @param  {int} count  Desired length of output string.  To pad on the left,
		 * use a positive integer.  A negative integer results in right padding.
		 * @param  {string} padchar   Pad character.  No effort is made to ensure it is
		 * only one character, so if it is longer than that it will affect the total
		 * length!
		 * @return {string}        Padded string
		 */
		this.pad_string = function(string, count, padchar)
		{
			string = string.toString();
			var raw_len = Math.abs(count) - string.length;
			if (raw_len <= 0)
			{
				return string;
			}

			var padding = '';
			for (var i = 0; i < raw_len; i++)
			{
				padding += padchar;
			}

			if (count > 0)
			{
				return padding + string;
			}
			else
			{
				return string + padding;
			}
		};

		/**
		 * Return a nicely formatted current timestamp including the current date, and
		 * time with MS
		 * @return {string} Formatted timestamp
		 */
		this.current_datetime = function()
		{
			var now = new Date();
			var date = [ now.getFullYear(), now.getMonth() + 1, now.getDate() ];
			var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];

			for ( var i = 1; i < 3; i++ )
			{
				if (i < 2)
				{
					date[i] = this.pad_string(date[i], 2, "0");
				}

				time[i] = this.pad_string(time[i], 2, "0");
			}

			return date.join("-") + " " + time.join(":") + "." + this.pad_string(now.getMilliseconds(), 3, "0");
		};

		// Logging functions

		/**
		 * Write a log message to the console
		 * @param  {string} level   Log level.  Anything that exists in "console" is
		 * acceptable as a level:
		 * - debug
		 * - info/log
		 * - warn
		 * - error
		 * @param  {string} message Message to log.  Additional arguments are interpolated
		 * into this message as defined in the console logging specification (supported by
		 * all major browsers, see https://developer.mozilla.org/en-US/docs/Web/API/console.log
		 * for more details).  The invocation is effectively identical to that defined
		 * by MDN with the exception of the first parameter, which is always the log level.
		 * (Hint: to log objects with full inspection capabilities, use method('%o', object))
		 * @return {null}
		 */
		this._log = function(level, message)
		{
			if (!this.is_enabled)
			{
				return;
			}

			if (!level.match(/^(debug|log|info|warn|error)$/))
			{
				message = "(Invalid level: '" + level + "') " + message;
				level = 'error';
			}

			var raw_args = Array.prototype.slice.call(arguments, 2);
			var args = [level, "%s [%s: %s] " + message];
			args = args.concat([this.current_datetime(), this.pad_string(level.toUpperCase(), -6, ' '), this.module]);
			args = args.concat(raw_args);
			this.queue.push(args);

			if (typeof console !== 'undefined')
			{
				for (var i = 0; i < this.queue.length; i++)
				{
					console[this.queue[i][0]].apply(console, this.queue[i].slice(1));
				}
				this.queue = [];
			}
		};

		/**
		 * Write a debug message to the console.  See _log() for more details as the
		 * arguments (other than the level argument) are identical
		 * @return {null}
		 */
		this.debug = function()
		{
			return this._log.apply(this, ['debug'].concat(Array.prototype.slice.call(arguments)));
		};

		/**
		 * Write a error message to the console.  See _log() for more details as the
		 * arguments (other than the level argument) are identical
		 * @return {null}
		 */
		this.error = function()
		{
			return this._log.apply(this, ['error'].concat(Array.prototype.slice.call(arguments)));
		};

		/**
		 * Write a info message to the console.  See _log() for more details as the
		 * arguments (other than the level argument) are identical
		 * @return {null}
		 */
		this.info = function()
		{
			return this._log.apply(this, ['info'].concat(Array.prototype.slice.call(arguments)));
		};

		/**
		 * Write a log message to the console.  See _log() for more details as the
		 * arguments (other than the level argument) are identical
		 * @return {null}
		 */
		this.log = function()
		{
			return this._log.apply(this, ['log'].concat(Array.prototype.slice.call(arguments)));
		};

		/**
		 * Write a warn message to the console.  See _log() for more details as the
		 * arguments (other than the level argument) are identical
		 * @return {null}
		 */
		this.warn = function()
		{
			return this._log.apply(this, ['warn'].concat(Array.prototype.slice.call(arguments)));
		};

		/**
		 * Log one or more javascript objects to the console
		 * @return {null}
		 */
		this.obj = function()
		{
			var message = this.pad_string('', arguments.length, '%o ');
			return this._log.apply(this, ['debug', message].concat(Array.prototype.slice.call(arguments)));
		};
	};

	/**
	 * Holds a reference to all rubix_log instances.  Used for global functions like
	 * enable() and disable().
	 * @type {Array}
	 */
	rubix_log._instances = [];

	/**
	 * Real defaults for new rubix_log objects - this enables us to globally enable/disable
	 * features for not only existing objects but future ones.
	 * @type {Object}
	 */
	rubix_log._defaults = {
		'show_timestamp':	true,
		'is_enabled':		undefined
	};

	/**
	 * Set several properties on rubix_log:
	 * - _debug: list of debug things passed in via the QS
	 * - _lmi: current LMI
	 * - _zbug: Whether zbug is enabled
	 * - can_enable: Whether we want to enable debugging by default for this URL:
	 * -- If the "debug" query string parameter is present and has a value (any value)
	 * -- If the current LMI is negative (only applies when lmi is actually present in the QS)
	 * -- If ZBUG is in use
	 */
	(function() {
		rubix_log._debug = [];
		rubix_log._lmi = 0;
		rubix_log._zbug = false;
		rubix_log.can_enable = false;

		var qs = window.location.search.replace(/^\?/, '');
		qs = qs.split('&');
		for (var i = 0; i < qs.length; i++)
		{
			var kv = qs[i].split('=');
			if (kv.length > 0)
			{
				if (kv[0] == 'debug')
				{
					rubix_log._debug = kv[1].length > 0 ? kv[1].split(',') : [];
				}
				else if (kv[0] == 'lmi')
				{
					rubix_log._lmi = parseInt(kv[1], 10);
				}
				else if (kv[0] == '_zbug')
				{
					rubix_log._zbug = true;
				}
			}
		}

		rubix_log.can_enable = (
				rubix_log._debug.length > 0
			||	rubix_log._lmi < 0
			||	rubix_log._zbug
		);
	})();

	/**
	 * Enable logging.  If called on rubix_log, it globally enables logging for all
	 * current and future objects.  If called on an instance of rubix_log, it only affects
	 * that single instance
	 * @return {null}
	 */
	rubix_log.enable = function()
	{
		if (this === rubix_log)
		{
			rubix_log._defaults.is_enabled = true;
			for (var i = 0; i < rubix_log._instances.length; i++)
			{
				rubix_log._instances[i].is_enabled = true;
			}
		}
		else
		{
			this.is_enabled = true;
		}
	};

	/**
	 * Disable logging.  If called on rubix_log, it globally disabled logging for all
	 * current and future objects.  If called on an instance of rubix_log, it only affects
	 * that single instance
	 * @return {null}
	 */
	rubix_log.disable = function()
	{
		if (this === rubix_log)
		{
			rubix_log._defaults.is_enabled = false;
			for (var i = 0; i < rubix_log._instances.length; i++)
			{
				rubix_log._instances[i].is_enabled = false;
			}
		}
		else
		{
			this.is_enabled = false;
		}
	};
}
catch (e)
{
	if (typeof console !== 'undefined' && typeof console.error !== 'undefined')
	{
		console.error("An error occurred creating the logging subsystem or while logging: %o", e);
	}
	if (typeof rubix_log === 'undefined')
	{
		rubix_log = function(module)
		{
			this.pad_string = function(string, count, padchar) { return string; };
			this.current_datetime = function() { return ''; };
			this.check_enabled = function() { return false; };
			this._log = function(level, message) { return; };
			this.debug = function() { return; };
			this.error = function() { return; };
			this.info = function() { return; };
			this.log = function() { return; };
			this.warn = function() { return; };
			this.obj = function() { return; };
		};
		rubix_log._instances = [];
		rubix_log._defaults = {};
		rubix_log.enable = function() { return; };
		rubix_log.disable = function() { return; };
	}
}


/*
 * Facebox (for jQuery)
 * version: 1.2 (05/05/2008)
 * @requires jQuery v1.2 or later
 *
 * Examples at http://famspam.com/facebox/
 *
 * Licensed under the MIT:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright 2007, 2008 Chris Wanstrath [ chris@ozmm.org ]
 *
 * Usage:
 *
 *  jQuery(document).ready(function() {
 *    jQuery('a[rel*=facebox]').facebox()
 *  })
 *
 *  <a href="#terms" rel="facebox">Terms</a>
 *    Loads the #terms div in the box
 *
 *  <a href="terms.html" rel="facebox">Terms</a>
 *    Loads the terms.html page in the box
 *
 *  <a href="terms.png" rel="facebox">Terms</a>
 *    Loads the terms.png image in the box
 *
 *
 *  You can also use it programmatically:
 *
 *    jQuery.facebox('some html')
 *
 *  The above will open a facebox with "some html" as the content.
 *
 *    jQuery.facebox(function($) {
 *      $.get('blah.html', function(data) { $.facebox(data) })
 *    })
 *
 *  The above will show a loading screen before the passed function is called,
 *  allowing for a better ajaxy experience.
 *
 *  The facebox function can also display an ajax page or image:
 *
 *    jQuery.facebox({ ajax: 'remote.html' })
 *    jQuery.facebox({ image: 'dude.jpg' })
 *
 *  Want to close the facebox?  Trigger the 'close.facebox' document event:
 *
 *    jQuery(document).trigger('close.facebox')
 *
 *  Facebox also has a bunch of other hooks:
 *
 *    loading.facebox
 *    beforeReveal.facebox
 *    reveal.facebox (aliased as 'afterReveal.facebox')
 *    init.facebox
 *
 *  Simply bind a function to any of these hooks:
 *
 *   $(document).bind('reveal.facebox', function() { ...stuff to do after the facebox and contents are revealed... })
 *
 */

(function($) {
  $.facebox = function(data, klass) {
    $.facebox.loading()
    if (data.ajax) fillFaceboxFromAjax(data.ajax)
    else if (data.image) fillFaceboxFromImage(data.image)
    else if (data.div) fillFaceboxFromHref(data.div,klass)
    else if ($.isFunction(data)) data.call($)
    else $.facebox.reveal(data, klass)

  }

  /*
   * Public, $.facebox methods
   */

  $.extend($.facebox, {
    ele: {
      wrap:null,
      close:null,
      close_image:null,
      body:null,
      content:null
    },
    settings: {
      opacity      : 0.5,
      overlay      : true,
      loadingImage : facebox_image_path + 'loading.gif',
      closeImage   : facebox_image_path + 'closelabel.gif',
      imageTypes   : [ 'png', 'jpg', 'jpeg', 'gif' ],
      faceboxHtml  : '\
    <div id="facebox" style="display:none;"> \
      <div class="popup"> \
        <table> \
          <tbody> \
            <tr> \
              <td class="tl"/><td class="b"/><td class="tr"/> \
            </tr> \
            <tr> \
              <td class="b"/> \
              <td class="body"> \
                <div class="content"> \
                </div> \
                <div class="footer"> \
                  <a href="#" class="close"> \
                    <i class="icon-remove"> \
                    <img src="' + facebox_image_path + 'closelabel.gif" title="close" class="close_image" /> \
                    </i> \
                  </a> \
                </div> \
              </td> \
              <td class="b"/> \
            </tr> \
            <tr> \
              <td class="bl"/><td class="b"/><td class="br"/> \
            </tr> \
          </tbody> \
        </table> \
      </div> \
    </div>'
    },

    loading: function() {
      init()
      if ($('#facebox .loading').length == 1) return true
      showOverlay()

      $.facebox.ele.content.empty()
      $.facebox.ele.body.children().hide().end()
        .append('<div class="loading"><img src="'+$.facebox.settings.loadingImage+'"/></div>')

      $.facebox.ele.wrap.css({
        top:	getPageScroll()[1] + (getPageHeight() / 10),
        left:	($(window).width() / 2 - ($('#facebox table').width() / 2))
      }).show()

      $(document).bind('keydown.facebox', function(e) {
        if (e.keyCode == 27) $.facebox.close()
        return true
      })
      $(document).trigger('loading.facebox')
    },

    reveal: function(data, klass) {
      $(document).trigger('beforeReveal.facebox', [$.facebox.ele])
      if (klass) $.facebox.ele.wrap.addClass(klass)
      if (klass) $.facebox.ele.content.addClass(klass)
      $.facebox.ele.content.html(data)
      $('#facebox .loading').remove()
      $.facebox.ele.body.children().fadeIn('normal')
      $.facebox.ele.wrap.css('left', $(window).width() / 2 - ($('#facebox table').width() / 2))
      $(document)
        .trigger('reveal.facebox', [$.facebox.ele])
        .trigger('afterReveal.facebox', [$.facebox.ele])
    },

    close: function(e) {
      // GFOR-GFOR-1581 don't stop propagation (see below) but let's prevent default behavior so we dont scroll to top of page when 'x' clicked
      if (typeof(e) != 'undefined') {
		e.preventDefault();
      }
      $(document).trigger('close.facebox')
      // NOTE: return false here stops propagation, causing other events attached to closing elements to not continue on, so commenting out
      // return false
    }
  })

  /*
   * Public, $.fn methods
   */

  $.fn.facebox = function(settings) {
    init(settings)

    function clickHandler() {
      $.facebox.loading(true)

      // support for rel="facebox.inline_popup" syntax, to add a class
      // also supports deprecated "facebox[.inline_popup]" syntax
      var klass = this.rel.match(/facebox\[?\.(\w+)\]?/)
      if (klass) klass = klass[1]

      fillFaceboxFromHref(this.href, klass)
      return false
    }

    return this.click(clickHandler)
  }

  /*
   * Private methods
   */

  // called one time to setup facebox on this page
  function init(settings) {
    if ($.facebox.settings.inited) return true
    else $.facebox.settings.inited = true

    $(document).trigger('init.facebox')
    makeCompatible()

    var imageTypes = $.facebox.settings.imageTypes.join('|')
    $.facebox.settings.imageTypesRegexp = new RegExp('\.' + imageTypes + '$', 'i')

    if (settings) $.extend($.facebox.settings, settings)
    $('body').append($.facebox.settings.faceboxHtml)

    $.facebox.ele.wrap = $('#facebox');
    $.facebox.ele.close = $('.close', $.facebox.ele.wrap);
    $.facebox.ele.close_image = $('.close_image', $.facebox.ele.wrap);
    $.facebox.ele.body = $('.body', $.facebox.ele.wrap);
    $.facebox.ele.content = $('.content', $.facebox.ele.wrap);

    var preload = [ new Image(), new Image() ]
    preload[0].src = $.facebox.settings.closeImage
    preload[1].src = $.facebox.settings.loadingImage

    $.facebox.ele.wrap.find('.b:first, .bl, .br, .tl, .tr').each(function() {
      preload.push(new Image())
      preload.slice(-1).src = $(this).css('background-image').replace(/url\((.+)\)/, '$1')
    })

    $.facebox.ele.close.click($.facebox.close)
    $.facebox.ele.close_image.attr('src', $.facebox.settings.closeImage)
  }

  // getPageScroll() by quirksmode.com
  function getPageScroll() {
    var xScroll, yScroll;
    if (self.pageYOffset) {
      yScroll = self.pageYOffset;
      xScroll = self.pageXOffset;
    } else if (document.documentElement && document.documentElement.scrollTop) {	 // Explorer 6 Strict
      yScroll = document.documentElement.scrollTop;
      xScroll = document.documentElement.scrollLeft;
    } else if (document.body) {// all other Explorers
      yScroll = document.body.scrollTop;
      xScroll = document.body.scrollLeft;
    }
    return new Array(xScroll,yScroll)
  }

  // Adapted from getPageSize() by quirksmode.com
  function getPageHeight() {
    var windowHeight
    if (self.innerHeight) {	// all except Explorer
      windowHeight = self.innerHeight;
    } else if (document.documentElement && document.documentElement.clientHeight) { // Explorer 6 Strict Mode
      windowHeight = document.documentElement.clientHeight;
    } else if (document.body) { // other Explorers
      windowHeight = document.body.clientHeight;
    }
    return windowHeight
  }

  // Backwards compatibility
  function makeCompatible() {
    var $s = $.facebox.settings

    $s.loadingImage = $s.loading_image || $s.loadingImage
    $s.closeImage = $s.close_image || $s.closeImage
    $s.imageTypes = $s.image_types || $s.imageTypes
    $s.faceboxHtml = $s.facebox_html || $s.faceboxHtml
  }

  // Figures out what you want to display and displays it
  // formats are:
  //     div: #id
  //   image: blah.extension
  //    ajax: anything else
  function fillFaceboxFromHref(href, klass) {
    // div
    if (href.match(/#/)) {
      var url    = window.location.href.split('#')[0]
      var target = href.replace(url,'')
      $.facebox.reveal($(target).clone().show(), klass)

    // image
    } else if (href.match($.facebox.settings.imageTypesRegexp)) {
      fillFaceboxFromImage(href, klass)
    // ajax
    } else {
      fillFaceboxFromAjax(href, klass)
    }
  }

  function fillFaceboxFromImage(href, klass) {
    var image = new Image()
    image.onload = function() {
      $.facebox.reveal('<div class="image"><img src="' + image.src + '" /></div>', klass)
    }
    image.src = href
  }

  function fillFaceboxFromAjax(href, klass) {
	  $.get(href, function(data) {
		  $.facebox.reveal(data, klass)
	  }).fail(function() {
		  $.get(href.replace('www.answers', 'wiki.answers'), function(data) {
			  $.facebox.reveal(data, klass)
		  })
	  })
  }

  function skipOverlay() {
    return $.facebox.settings.overlay == false || $.facebox.settings.opacity === null
  }

  function showOverlay() {
    if (skipOverlay()) return

    if ($('facebox_overlay').length == 0)
      $("body").append('<div id="facebox_overlay" class="facebox_hide"></div>')

    $('#facebox_overlay').hide().addClass("facebox_overlayBG")
      .css('opacity', $.facebox.settings.opacity)
      .click(function() { $(document).trigger('close.facebox') })
      .fadeIn(200)
    return false
  }

  function hideOverlay() {
    if (skipOverlay()) return

    $('#facebox_overlay').fadeOut(200, function(){
      $("#facebox_overlay").removeClass("facebox_overlayBG")
      $("#facebox_overlay").addClass("facebox_hide")
      $("#facebox_overlay").remove()
    })

    return false
  }

  /*
   * Bindings
   */

  $(document).bind('close.facebox', function() {
    $(document).unbind('keydown.facebox')
    $.facebox.ele.wrap.fadeOut(function() {
      $.facebox.ele.content.removeClass().addClass('content')
      hideOverlay()
      $('#facebox .loading').remove()
    })
    setTimeout(function(){$('#facebox').removeAttr('style').removeClass().hide();},1000)
    $(document).trigger('facebox_closed')
  })

})(jQuery);

jQuery(document).ready(
	function()
	{
		jQuery('a[rel*=facebox]').facebox()
	}
);


$(document).on('login_required', function(evt, initial_screen, welcome_counter, welcome_header, welcome_message, redirect_url, onboarding){


	$this = $(".js-js_login");

	var params = $this.data('jsparams');

	var url = "/tools/login";

	var login_redirect;

	if(typeof redirect_url !== 'undefined' && redirect_url !== '') {
		login_redirect = redirect_url;
	}
	else{
		login_redirect = params.login_redirect;
	}

	var redirect = function(url){
		if(url.length <= 1 || $.trim(url).toLowerCase() == 'reload'){
			// need to replace onboarding get param with complete if there
			// twitter login sends through "in_process" and this causes
			// cat picker to infinitely reload
			url = replace_onboarding_get_param( window.location.href );
		}
		else if(url.charAt(0) == "/"){
			var host = window.location.host;
			if($.inArray("wiki.answers.com", host) > -1){
				host = host.replace("wiki.answers.com", "www.answers.com");
			}
			url = 'http://'+ host + url;
		}
		if(window.location.href==url){
			window.location.reload();
		}
		else{
			window.location.replace(url);
		}
	};

	var replace_onboarding_get_param = function(url){
		var a = url.split("?");
		var b = "";
		if(typeof a[1]!=='undefined'){
			var c = a[1].split("&");
			for(i=0;i<c.length;i++){
				var d = c[i].split("=");
				if(typeof d[0] !== "undefined"){
					if(b.length>0){
						b += "&";
					}
					if(d[0] != "onboarding"){
						b += c[i];
					}
					else {
						b += "onboarding=complete";
					}
				}
			}
		}
		if(b.length>0)
		{
			return a[0] + "?" + b;
		}
		return a[0];
    };

	if(typeof initial_screen !== 'undefined' && initial_screen !== '') {
		url = url + '?initial_screen=' + initial_screen;
		if(typeof welcome_counter !== 'undefined' && welcome_counter !== '') {
			url = url + '&welcome_counter=' + welcome_counter;
		}
		if(typeof fb_graph_version !== 'undefined' && fb_graph_version !== '') {
			url = url + '&fb_graph_version=' + fb_graph_version;
		}
		if(typeof welcome_header !== 'undefined' && welcome_header !== '') {
			url = url + '&welcome_header=' + welcome_header;
		}
		if(typeof welcome_message !== 'undefined' && welcome_message !== '') {
			url = url + '&welcome_message=' + welcome_message;
		}
		if(typeof onboarding !== 'undefined' && onboarding !== '') {
			url = url + '&onboarding=' + onboarding;
		}
	}
	$.facebox({ ajax: url });

	$('#facebox').addClass('js_login_modal');
	$('#facebox').find('.body').css({"opacity":"0"});
	$('#facebox').css({"width":"100%", "left":0, "top":0});

	$(document).on('login_successful', function(event){
		// Once we've logged in succesfully then we need to reload the page
		// if this is closed
		$(this).on('close.facebox', function(){
			redirect(login_redirect);
		});
	});

	$(document).on('onboard_complete', function(event){
		redirect(login_redirect);
	});

	$('body').addClass('facebox_login');

	$(this).on('reveal.facebox', function() {
        $('#facebox').find('.register, .password, .module.category_picker, .module.category_expertise').hide();
		$('body').addClass('facebox_open');
		$('body').addClass('facebox_fixed');
	});

	$(this).on('close.facebox', function() {
		$('body').removeClass('facebox_open');
		$('body').removeClass('facebox_fixed');
		$('body').removeClass('facebox_login');
	});

	$(this).on('afterReveal.facebox', function() {
		window.setTimeout(function() {
			$('#facebox').find('.body').css({"opacity":"1"});
		}, 1000);
	});
	return false;
});

$(document).on('do_logout', function(evt) {

	$this = $(".js-js_login");

	var params = $this.data('jsparams');

	var now = new Date();
	var time = now.getTime();
	time += (365 * 24 * 60 * 60);
	now.setTime(time);
	document.cookie="kal=yes;path=/;domain=.answers.com;expires=" + now.toGMTString();

	if(params.log_out_of_fb) {
		FB.getLoginStatus(function(response)
		{
			if (response.status === 'connected')
			{
				FB.logout(function(){
					if ("undefined" == typeof LogoutAjaxResponse) {
						LogoutAjaxResponse = AquaAjaxResponse.prototype.inherit("LogoutAjaxResponse", {
							status200: function(data) {
								window.location.reload();
							},
							statusERROR: function(data) {
								trackError(data.message);
							}
						});
					}
					var url = '/solo/user/logout';
					var ajaxResponse = new LogoutAjaxResponse();
					var resp = ajaxResponse.postJson(url);
				});
			}
			else if ("undefined" == typeof LogoutAjaxResponse)
			{
				LogoutAjaxResponse = AquaAjaxResponse.prototype.inherit("LogoutAjaxResponse", {
					status200: function(data) {
						window.location.reload();
					},
					statusERROR: function(data) {
						trackError(data.message);
					}
				});
				var url = '/solo/user/logout';
				var ajaxResponse = new LogoutAjaxResponse();
				var resp = ajaxResponse.postJson(url);
			}
		});
	} else {
		if ("undefined" == typeof LogoutAjaxResponse) {
			LogoutAjaxResponse = AquaAjaxResponse.prototype.inherit("LogoutAjaxResponse", {
				status200: function(data) {
					window.location.reload();
				},
				statusERROR: function(data) {
					trackError(data.message);
				}
			});
		}
		var url = '/solo/user/logout';
		var ajaxResponse = new LogoutAjaxResponse();
		var resp = ajaxResponse.postJson(url);
	}
});


(function ( $ ) {
  $.fn.extend({
	attrAddProp: function ( attr, prop ) {
		var $_this = this;
		var hasAttr = $_this.hasAttr(attr);

		if (hasAttr) {
			var modProp = ' ' + prop + ' ';
			var properties = $_this.attr(attr);
			var newProperties = $.trim(properties + modProp);
			$_this.attr(attr, newProperties);

			return this;
		}

		$_this.attr(attr, prop);
		return this;
	},

	attrHasProp: function ( attr, prop ) {
		var $_this = this;
		var hasAttr = $_this.hasAttr(attr);

		if (hasAttr === false) {
			return false;
		}

		var properties = $_this.attr(attr).split(' ');
		var i = 0;
		var l = properties.length;

		for (; i<l; i++) {
			var curProp = properties[i];
			if (curProp == prop) {
				return true;
			}
		}

		return false;
	},

	attrRemoveProp: function ( attr, prop ) {
		var $_this = this;
		var hasAttr = $_this.hasAttr(attr);
		var hasProp = $_this.attrHasProp(attr, prop);

		if (hasAttr && hasProp) {
			var properties = $_this.attr(attr);
			var newProperties = $.trim(properties.replace(prop, ''));
			$_this.attr(attr, newProperties);
		}

		return this;
	},

	hasAttr: function (attr) {
		var $_this = this;
		var i = 0;
		var l = $_this.length;

		for (; i<l; i++) {
			var ai = 0;
			var al = $_this[i].attributes.length;
			for (; ai<al; ai++) {
				var thisAttribute = $_this[i].attributes[ai].name;
				if (thisAttribute === attr) {
					return true;
				}
			}
		}

		return false;
	}
  });

})(jQuery);




(function($) {
	$('.module.header_redcarpet').each( function() {

		var $this = $(this);

		var params= $(this).data('jsparams');

		var eles = {
			frame					: $this.find('.frame'),
			login_button			: $this.find('.login_button'),
			signup_button			: $this.find('.signup_button'),
			signout_button		: $this.find('.sign_out'),
			profile_link			: $this.find('.profile_link'),
			settings_link			: $this.find('.settings_link'),
			all_submenus			: $this.find('.submenu'),
			user_menu					: $this.find('.menu_user'),
			user_button				: $this.find('.menu_user').find('button'),
			user_submenu			: $this.find('.submenu_user'),
			brand_link				: $this.find('li.user_link.brand_role a'),
			menu_toggle				: $this.find('button.menu_toggle'),
			notifications_menu		: $this.find('.menu_notifications'),
			notifications_button	: $this.find('.menu_notifications').find('button'),
			notifications_submenu	: $this.find('.submenu_notifications'),
			notifications_list		: $this.find('.notifications_list'),
			noticications_markr		: $this.find('.mark_all_notifs_read'),
			search_form						: $this.find('.search_form'),
			search_form_input			: $this.find('.search_form').find('.term'),
			search_submit_button	: $this.find('.search_form').find('.search_submit'),
			user_avatar						: $this.find('img.user_avatar'),
			user_button_text			: $this.find('button.user_button span'),
			body									: $this.closest('body')

		};

		var userTime =  new Date();

		var vars = {
			menu_delay_ms			: 400,
			open_user_menu			: false,
			open_notifications_menu	: false,
			notifications_to 		: "",
			max_notification_id 	: "",
			userTimeOffset 			: userTime.getTimezoneOffset(),
			external_profile_switch : false
		};

		var functions = {
			adjust_padding: function () {
				var args = [].slice.call(arguments);
				var padding_size = args[1] || undefined;
				if (padding_size === undefined || isNaN(padding_size)) {
					return false;
				}

				if (eles.body.hasAttr('data-padding') === false) {
					eles.body.attr('data-padding', padding_size);
					eles.body.css('padding-top', padding_size);
					return true;
				}

				var cur_padding = parseInt(eles.body.attr('data-padding'), 10);
				var new_padding = cur_padding + padding_size;

				if (new_padding < 0) {
					new_padding = 0;
				}
				eles.body.attr('data-padding', new_padding);
				eles.body.css('padding-top', new_padding);
				return true;
			},

			debounce: function(func, wait, immediate) {
				var timeout;
				return function() {
					var context = this, args = arguments;
					var later = function() {
						timeout = null;
						if (!immediate) func.apply(context, args);
					};
					var callNow = immediate && !timeout;
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
					if (callNow) func.apply(context, args);
				};
			},

			show_user_menu: function() {
				eles.user_submenu.removeClass('hide');
				vars.open_user_menu = true;
			},
			hide_user_menu: function() {
				eles.user_submenu.addClass('hide');
				vars.open_user_menu = false;
			},
			show_notifications_menu: function() {
				eles.notifications_submenu.removeClass('hide');
				vars.open_notifications_menu = true;
			},
			hide_notifications_menu: function() {
				eles.notifications_submenu.addClass('hide');
				vars.open_notifications_menu = false;
			},
			form_submit:function(event){
				event.preventDefault();

				var searchText =  $.trim(eles.search_form_input.val());
				var defaultText = $.trim(eles.search_form_input.attr('title'));

				if("" !== searchText && defaultText !== searchText) {
					$(eles.search_form).submit();
				} else {
					eles.search_form_input.addClass('error');
				}
			},
			load_new_profile_picture: function(ev, data){
				eles.user_avatar.attr('src', data);
			},

			brand_click: function(){

				var date = new Date();
				date.setTime(date.getTime() + (60 * 60 * 1000));
				document.cookie = "default_brand=" +  $(this).data('linktype') + "_" + $(this).data('linkid') + "; expires=" + date.toGMTString() + "; domain=.answers.com; path=/";

				eles.user_avatar.attr('src', $(this).find('img.brand_avatar').attr('src'));
				eles.user_button_text.text($(this).text());
				eles.profile_link.attr('href', $(this).data('profile'));
				eles.settings_link.attr('href', $(this).data('settings'));

				functions.hide_user_menu();

				if(!vars.external_profile_switch){
					$(document).trigger({ type: 'profile_switch', source: 'header_redcarpet', profile: $(this).data('linktype') + "_" + $(this).data('linkid') });
				}

				return false;
			},

			get_notifications: function(paginate_from_id,paginate_look){
				var url = "/solo/user/notificationcenter";
				if(!paginate_look&&paginate_from_id)
				{
					paginate_look = "before";
				}
				var params = {
					"do":"get",
					paginate_from_id:paginate_from_id,
					paginate_look:paginate_look
				};
				$.ajax({
					url      : url,
					type     : 'GET',
					dataType : 'json',
					data     : params,
					success  : function(response) {
						var $ul = eles.notifications_list;
						var uls = [];
						var i = 0;
						$.each(response.results.notifications,function(index,notification){
							if(i==0) {
								paginate_from_id = notification["id"];
								if(paginate_look!=="after") {
									vars.max_notification_id = paginate_from_id;
								}
								i++;
							}
							var $li = $ul.find(".menu_notification_template."+notification["type"]).clone();
							if($li) {
								$li.removeClass("menu_notification_template");
								$li.removeClass("hide");
								$li.addClass("menu_notification");
								$li.addClass(notification["status"]);
								$li.html(functions.jsonsprintf(notification,$li.html()));
								$li.data("id",notification["id"]);
								$li.find("a").each(function(){
									if($(this).attr("href")==""){
										$(this).replaceWith($(this).html());
									}
								});
								uls.push($li);
							}
						});
						if(uls.length) {
							eles.notifications_menu.find(".spinner").addClass("hide");
							eles.notifications_menu.find(".mark_all_notifs_read").removeClass("hide");
							$ul.removeClass("hide");
							if(paginate_look=="before") {
								uls.reverse();
							}
							$.each(uls,function(i,$li){
								if(paginate_look=="before") {
									$ul.find(".menu_notification:first").before($li);
								}
								else {
									$ul.find(".menu_notification:last").after($li);
								}
							});
							if(response.results.total_unseen_notifications) {
								eles.notifications_menu.addClass("active");
								eles.notifications_menu.find(".notification_count").html(response.results.total_unseen_notifications).removeClass("hide");
							}
							$ul.find(".menu_notification.seen").on("click",function(){
								$.ajax({
									url      : url,
									type     : 'GET',
									data     : {
										"do" : "markread",
										"notification_id" : $(this).data("id")
									}
								});
								$(this).removeClass("seen").addClass("read");
							});
						}
						else if( !eles.notifications_menu.find(".spinner").hasClass("hide") )
						{
							// if the spinner is showing, hide and show no notifications
							eles.notifications_menu.find(".no_notifications").removeClass("hide");
							eles.notifications_menu.find(".spinner").addClass("hide");
						}
						// loop through everything and update display
						eles.notifications_list.find(".timestamp").each(function(){
							var unixTimestamp = $(this).data("unixtimestamp");
							if(unixTimestamp&&unixTimestamp!=='{unixtimestamp}'){
								$(this).html(functions.displayTime(unixTimestamp));
							}
						});
						if(paginate_look !== "after"){
							vars.notifications_to = setTimeout(function(){functions.get_notifications(paginate_from_id,"before");},10000);
						}
					},
					error  : function(){

					}
				});
			},
			jsonsprintf: function(json,string,prevkey) {
				for(var key in json) {
					var composite_key = key;
					if(prevkey) {
						composite_key = prevkey + ":" + key;
					}
					if(typeof json[key] === "object" || typeof json[key] === "array") {
						string = functions.jsonsprintf(json[key],string,composite_key);
					}
					else {
						string = string.split("{"+composite_key+"}").join(json[key]);
					}
				}
				return string;
			},
			displayTime: function(unixTimestamp){
				var secondsAgo = (Math.floor((new Date).getTime()/1000)-unixTimestamp);
				if( secondsAgo < 60 ){
					return "moments ago";
				}
				else if ( secondsAgo < 3600 ) {
					var minutes = Math.floor(secondsAgo/60);
					return minutes + " minute" + ((minutes>1)?"s":"") + " ago";
				}
				else if ( secondsAgo < 86400 ) {
					var hours = Math.floor(secondsAgo/3600);
					return hours + " hour" + ((hours>1)?"s":"") + " ago";
				}
				else {
					var days = Math.floor(secondsAgo/86400);
					return days + " day" + ((days>1)?"s":"") + " ago";
				}
			},
			markAllRead: function() {
				$.ajax({
					url: "/solo/user/notificationcenter",
					data: {
						"do":"markread",
						notification_id:"all",
						max_id:vars.max_notification_id
					}
				});
				eles.notifications_list.find(".unseen").addClass("read").removeClass("unseen");
				eles.notifications_list.find(".seen").addClass("read").removeClass("seen");
			}
		};

		/*
		 * MENU TOGGLE
		 */
		eles.menu_toggle.on('click', function (event) {
			if ($this.hasClass('menu_toggle')) {
				$this.removeClass('menu_toggle');
				return;
			}

			$this.addClass('menu_toggle');
			return;
		});

		/*
		 * SET CLASS IF FIXED HEADER
		 * SET UP LISTENER FOR ADJUSTING BODY PADDING
		*/
		if( params.fixed === "yes" ) {
			$(document).on('adjust_body_padding', functions.adjust_padding);

			vars.header_height = eles.frame.innerHeight();
			if (parseInt($(window).outerWidth(true)) <= 799) {
				vars.isBrowserSmall = true;
			}
			else {
				vars.isBrowserSmall = false;
			}
			$(document).trigger('adjust_body_padding', vars.header_height);

			$('body').addClass('header_fixed');
		}


		/* SEARCH BAR EVENT HANDLERS
		 *  ON click or focused enter, submit search form
		 *  ON focus or change, remove error class
		 */
		eles.search_submit_button.on('click', function (e) {
			functions.form_submit(e);
		});
		eles.search_form_input.on('keypress', function (e) {
			if(e.which == 13) { // enter key pressed
				functions.form_submit(e);
			}
		});
		eles.search_form_input.on('focus change',function () {
			$(this).removeClass('error');
		});

		/* USER LOGIN/SIGNUP EVENT HANDLERS
		 *  ON Login click, call to js/login Log In page
		 *  ON Signup click, call to js/login Sign Up page
		 */
		eles.login_button.on('click', function() {
			if( params.login_params !== '' ) {
				var login_params = params.login_params.split(",");
				$(document).trigger("login_required", login_params);
			}
			else {
				$(document).trigger("login_required", "login");
			}
		});
		eles.signup_button.on('click', function() {
			$(document).trigger("login_required", "signup");
		});

		/* USER SIGNOUT EVENT HANDLERS
		 *  ON Signout click, call to js/login do_logout function
		 */
		eles.signout_button.on('click', function(evt) {
			evt.preventDefault();
			$(document).trigger("do_logout");
		});

		/* USER MENU EVENT HANDLERS
		 *  ON user_button click, unhide user submenu
		 *  When mouse leaves menu, delay on closing window
		 *  If mouse reenters before close, clears timer
		 */
		eles.user_button.on('click', function() {
			if(vars.open_notifications_menu) {
				functions.hide_notifications_menu();
			}
			if(vars.open_user_menu) {
				functions.hide_user_menu();
			}
			else {
				functions.show_user_menu();
			}
		});
		eles.user_menu.on('mouseleave', function(){
			if(vars.open_user_menu) {
				window.user_menu_delay = setTimeout(function() {
					if(vars.open_user_menu) {
						functions.hide_user_menu();
					}
				}, vars.menu_delay_ms);
			}
		});
		eles.user_menu.on('mouseenter', function(){
			if(vars.open_user_menu) {
				clearTimeout(window.user_menu_delay);
			}
		});
		eles.brand_link.on('click', functions.brand_click);

		/* NOTIFICATIONS MENU EVENT HANDLERS
		 *  ON notifications_button click, unhide notifications submenu
		 *  When mouse leaves menu, delay on closing window
		 *  If mouse reenters before close, clears timer
		 */
		eles.notifications_button.on('click', function() {
			if(vars.open_user_menu) {
				functions.hide_user_menu();
			}
			if(vars.open_notifications_menu) {
				functions.hide_notifications_menu();
			}
			else {
				functions.show_notifications_menu();
			}
			if(eles.notifications_menu.hasClass('active'))
			{
				eles.notifications_menu.removeClass('active');
				$.ajax({
					url: "/solo/user/notificationcenter",
					data: {
						"do":"markseen",
						notification_id:"all",
						max_id:vars.max_notification_id
					}
				});
				eles.notifications_button.find(".notification_count").addClass("hide");
				eles.notifications_list.find("unseen").addClass("seen").removeClass("unseen");
			}
		});
		eles.notifications_menu.on('mouseleave', function(){
			if(vars.open_notifications_menu) {
				window.notifications_menu_delay = setTimeout(function() {
					if(vars.open_notifications_menu) {
						functions.hide_notifications_menu();
					}
				}, vars.menu_delay_ms);
			}
		});
		eles.notifications_menu.on('mouseenter', function(){
			if(vars.open_notifications_menu) {
				clearTimeout(window.notifications_menu_delay);
			}
		});

		/* USER UPDATES PROFILE PICTURE
		 *  ON new_profile_picture, call to update profile picture function
		 */
		$(document).on('new_profile_picture', functions.load_new_profile_picture);

		$(document).on('profile_switch', function(event){

			if(event.source == "header_redcarpet"){
				return false;
			}

			vars.external_profile_switch = true;
			window.external_click_delay = setTimeout(function(){
				vars.external_profile_switch = false;
			}, 100);

			var profile_selected = event.profile.split("_");
			if(profile_selected[0] == "brand"){
				$this.find("li.user_link.brand_role [data-linktype='brand'][data-linkid='" + profile_selected[1] + "']").trigger('click');
			}
			else{
				$this.find("li.user_link.brand_role [data-linktype='user']").trigger('click');
			}

		});

		/* AUTOHIDE SUPPORT
		 * When set to no, we do nothing.
		 * When set to yes, we hide the entire header when the user scrolls away from the top of the page.
		 * When the user scrolls back towards the top of the page, we slide the hidden elements back into view.
		 * In the scroll event handler, checks are done to prevent queueing animations, whether we need to do anything,
		 *  which direction we're going and if we're above/below the fold
		 */
		if(params.fixed === "yes" && params.autohide === "yes" && params.autohide_secondarynav === false){
			var scrollDir = function(){
				var currTop = window.comAnswersPageCurrTop || -1,offset=window.pageYOffset;
				window.comAnswersPageCurrTop = offset;
				if(offset > currTop){
					return -1; //DOWN
				}
				if(offset < currTop){
					return 1; //UP
				}
				return false; //STATIC OR WAT?
			};

			window.headerAnimated = false;
			$(window).on("scroll", function(){
				var dir = scrollDir();
				var windowHeight = $(window).height();
				var doShow = (!window.headerAnimated && !$this.is(":visible") && (dir>0 || window.pageYOffset < windowHeight));
				var doHide = (!window.headerAnimated && $this.is(":visible") && (dir<0 && window.pageYOffset > windowHeight));
				if(doShow||doHide){
					var enableAnimation = function(){
						setTimeout(function(){
							window.headerAnimated = false;
						},150);
					};
					if(doShow){
						$this.slideDown(100,enableAnimation);
					} else {
						$this.slideUp(100,enableAnimation);
					}
				}
			});
		}

		// BROWSER RESIZE EVENT
		$(window).resize(
			functions.debounce(function() {
				if (parseInt($(window).outerWidth(true)) <= 799 && !vars.isBrowserSmall) {
					vars.isBrowserSmall = true;
					var header_diff = eles.frame.innerHeight() - vars.header_height;
					vars.header_height = eles.frame.innerHeight();
					$(document).trigger('adjust_body_padding', header_diff);
				}
				else if (parseInt($(window).outerWidth(true)) > 799 && vars.isBrowserSmall) {
					vars.isBrowserSmall = false;
					var header_diff = eles.frame.innerHeight() - vars.header_height;
					vars.header_height = eles.frame.innerHeight();
					$(document).trigger('adjust_body_padding', header_diff);
				}
			}, 250)
		);

		/* AUTOHIDE SECONDAY NAV
		 * If no, do nothing
		 * If yes (and fixed is on and autohide is off) on user scrolling we hide the secondary nav and when the stop (for at leas 500ms) we show it again.
		 */
		if (params.fixed === "yes" && params.autohide === "no" && params.autohide_secondarynav === true) {
			$this.addClass('nav_will_be_hidden');

			$(window).on("scroll", function () {
				clearTimeout($.data(document, 'scrollTimer'));

				var timer = 500; // THIS COULD BE TURNED INTO A CONFIG IF WE WANTED TO SPLIT TEST IT.
				if ($this.hasClass('hide_secondarynav') === false) {
					$this.addClass('hide_secondarynav');
				}

				$.data(document, 'scrollTimer', setTimeout(function() {
					$this.removeClass('hide_secondarynav');
				}, timer));
			});
		}

		if(params.is_logged_in=="yes"){
			$(document).ready(function(){
				functions.get_notifications();
			});
		}

		eles.noticications_markr.on("click",function(){
			functions.markAllRead();
		});

	});
})( jQuery );


!function ($) {
	$(function (){
		$('input[asg-tooltip], img[asg-tooltip], button[asg-tooltip]').each(modifyNoContentElements);

		$(document).on('mouseenter', 'input[asg-tooltip], img[asg-tooltip], button[asg-tooltip]', modifyNoContentElements);
	});

	var modifyNoContentElements = function (event) {
		var args = [].slice.call(arguments);
		var $source = args[1] !== undefined ? $(args[1]) : $(event.target);
		var sourceTooltip = $source.attr('asg-tooltip');
		var sourceDataText = $source.data('tooltip');
		$source.removeAttr('asg-tooltip').removeAttr('data-tooltip');
		$source.wrap('<span class="tooltip" asg-tooltip="' + sourceTooltip + '" data-tooltip=" ' + sourceDataText + ' "></span>');
	};
}(jQuery);


var question_flag_modal = (function($){

	var added_flags = [],
		removed_flags = [],
		is_dirty = false,
		mc_key = '',

		elements = {
		acquire:function() {
			this.content = $('.question_flag_modal div.flag_modal_container');
			this.params = $('.question_flag_modal').data('jsparams');
			this.section = $('.question_flag_modal section');
			this.section_head = $('.question_flag_modal .section_head');
			this.chevrons = $('.question_flag_modal section .section_head i');
			this.issue_list = $('.question_flag_modal ul.issue_list');
			this.save = $('.question_flag_modal button.flag_save');
			this.issue_count = $('.question_flag_modal span.issue_counter');
			this.checkbox = $('.question_flag_modal input.issue_checkbox');
			this.issue = $('.question_flag_modal span.issue_label');
			this.comments = $('.question_flag_modal textarea.issue_input');
			this.cur_id = $('.question_flag_modal input.cur_id').val();
			this.etag = $('.question_flag_modal input.etag').val();
			this.title = $('.question_flag_modal input.title').val();
			this.error = $('.question_flag_modal div.error');
			this.save_lock = $('.question_flag_modal button.save_lock');
			this.lock_label = $('.question_flag_modal span.lock_label');
			this.lock_checkbox = $('.question_flag_modal input.lock_checkbox');
		}
	},

	ev = {
		bind:function(){
			$(document).on('facebox_closed', function() {
				var $facebox = $('div#facebox');
				if ($facebox.hasClass('question_lock_modal')) {
					_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi,'modal_closed|'+ Number(elements.cur_id)+'']);
					$facebox.removeClass('question_flag_modal');
					$facebox.removeClass('question_lock_modal');
				} else if ($facebox.hasClass('question_flag_modal')) {
					_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'modal_closed|'+ Number(elements.cur_id)+'']);
					$facebox.removeClass('question_flag_modal');
				}
			});

			$(elements.section_head).bind('click', ev.openSection);
			$(elements.checkbox).bind('change', ev.flagCheck);
			$(elements.save).bind('click', ev.saveFlags);
			$(elements.issue).bind('click', ev.issueClick);

			$(elements.lock_label).bind('click', ev.lockClick);
			$(elements.lock_checkbox).bind('change', ev.lockCheck);
			$(elements.save_lock).bind('click', ev.saveLock);
		},

		lockClick:function(event){
			$(this).find('input.lock_checkbox').trigger('click');
			$(elements.lock_label).removeClass("selected");

			if(!$(this).parent().find('input.lock_checkbox').prop("disabled")){
				$(this).addClass("selected");
			}
		},

		lockCheck:function(event){
			event.stopPropagation();
			var reason = $(this).data('reason');
			$(elements.lock_label).each(function(){
				$(this).removeClass('selected');
			});
			if ($(this).attr('checked')){
				$(elements.save_lock).attr('asg-button', 'primary');
				$(this).parent().find('span.lock_label').addClass("selected");
				_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi, 'lock_selected|'+reason+'|'+Number(elements.cur_id)+'']);
			} else {
				$(elements.save_lock).attr('asg-button', 'primary disabled');
			}
			$(elements.lock_checkbox).not(this).each(function(){
				$(this).attr('checked', false);
			});
		},

		saveLock:function(event){
			$(elements.save_lock).attr('asg-button', 'primary disabled');
			event.preventDefault();
			var type = $(this).data('type'),
				reason = $('.question_flag_modal input.lock_checkbox:checked').data('reason'),
				endpoint = type == 'protect' ? '/ajax/protectQuestion.php' : '/ajax/preserveQuestion.php',
				data = {
					'title': encodeURIComponent(elements.title),
					'etag': encodeURIComponent(elements.etag),
					'jsonly': 1,
					'toProtect': 1,
					'media': 'screen',
					'action': 'preserve'
				};

			$.ajax({
				url: endpoint,
				type:'POST',
				data: data,
				dataType : 'json',
				success:function(response){
					if(response.status == 200){
						if(mc_key)
						{
							$.ajax({
								url: "/endpoint/memcache/delete",
								type:'POST',
								data: {
									'key': mc_key
								},
								dataType : 'json',
								success:function(response)
								{
									ev.saveReason(type, reason);
								}
							});
						}
						else
						{
							ev.saveReason(type, reason);
						}
					}
					else
					{
						var message = 'Sorry, there was a problem protecting the question.';
						elements.error.html(message);
						$(elements.save_lock).attr('asg-button', 'primary disabled');
					}
				},
				error:function(response){
					var message = 'Sorry, there was a problem protecting the question.';
					elements.error.html(message);
					$(elements.save_lock).attr('asg-button', 'primary disabled');
				}
			});
		},

		saveReason : function(type, reason){

			if (type == 'protect'){
				$.ajax({
					url: "/endpoint/questions/locks/reasons/create",
					type:'POST',
					data: {
						'questions_id': elements.cur_id,
						'reason': reason
					},
					dataType : 'json',
					success:function(response)
					{
						_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi, 'question_protected|'+reason+'|'+Number(elements.cur_id)+'']);
						_gaq.push(function() {
							$.facebox.close();
							location.reload();
						});
					}
				});
			}
			else {
				_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi, 'question_preserved|'+Number(elements.cur_id)+'']);
				_gaq.push(function() {
					$.facebox.close();
					location.reload();
				});
			}

		},

		issueClick:function(event){
			$(this).find('input.issue_checkbox').trigger('click');
		},

		saveFlags:function(event){
			event.preventDefault();
			if (!is_dirty){ return false; }
			var data = {
				'cur_id': elements.cur_id,
				'mc_key': mc_key,
				'added_flags': [],
				'removed_flags': removed_flags
			};
			var i;
			for (i=0; i<added_flags.length; i++){
				var comment = '';
				elements.comments.each(function(){
					if ($(this).data('flag_id') == added_flags[i]){
						comment = $(this).val();
					}
				});
				data.added_flags.push({
					'flag_id' : added_flags[i],
					'comment' : comment
				});
				_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'flag_added|'+added_flags[i]+'|'+Number(elements.cur_id)+'']);
			}
			for (i=0; i<removed_flags.length; i++){
				_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'flag_removed|'+removed_flags[i].flag_id+'|'+Number(elements.cur_id)+'']);
			}

			$.ajax({
				url: "/solo/question/flag/modal/save",
				type:'POST',
				data: data,
				dataType : 'json',
				success:function(response)
				{
					if (response.success){
						$.facebox.close();
						location.reload();
					} else {
						var message = 'Sorry, there was a problem saving your changes.  Please try again later.';
						if (response.message.length > 0){
							message = response.message;
						}
						elements.error.html(message);
					}
				}
			});
		},

		checkDirty:function(){
			if (removed_flags.length + added_flags.length === 0) {
				is_dirty = false;
				$(elements.save).attr('asg-button','primary disabled');
			} else {
				is_dirty = true;
				$(elements.save).attr('asg-button','primary');
			}
		},

		flagCheck:function(event){
			event.stopPropagation();
			var cur_flag_id = $(this).data('id');
			var flag_id = $(this).data('flag_id');
			var $issue_count = $(this).closest('.section').find('span.issue_counter');

			if ($(this).is(':checked')) {
				$(this).closest('ul.issue_list').find('input.issue_checkbox:enabled').not(this).each(function(){
					if ($(this).is(':checked')){
						$(this).click();
					}
				});
				$(this).parent('.issue_label').siblings('.issue_input').removeClass('hide');
				added_flags.push(flag_id);
				var counter = $issue_count.html();
				var new_count = ev.getIssueCount(counter, true);
				$issue_count.html(new_count);
				_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'flag_checked|'+flag_id+'|'+Number(elements.cur_id)+'']);
			} else {
				var counter = $issue_count.html();
				var new_count = ev.getIssueCount(counter, false);
				$issue_count.html(new_count);
				$(this).closest('ul.issue_list').find('input.issue_checkbox:disabled').each(function(){
					$(this).prop('disabled', false);
				});
				$(this).parent('.issue_label').siblings('.issue_input').addClass('hide').val('');
				var index = $.inArray(flag_id, added_flags);
				if ( index > -1 ) {
					added_flags.splice(index, 1);
				} else {
					removed_flags.push({
						'flag_id' : flag_id,
						'cur_flag_id' : cur_flag_id
					});
				}
				_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'flag_unchecked|'+flag_id+'|'+Number(elements.cur_id)+'']);
			}
			ev.checkDirty();
		},

		getIssueCount:function(countString, is_added){
			var new_count = parseInt(countString.match(/(\d+)+/g));
			if(is_added) {
				new_count = new_count + 1;
			} else {
				new_count = new_count - 1;
			}

			if(new_count == 1) {
				new_count = "(" + new_count + " issue)";
			} else {
				new_count = "(" + new_count + " issues)";
			}

			return new_count;
		},

		openSection:function(){
			if($(this).hasClass('open'))
			{
				return false;
			}

			elements.issue_list.slideUp();
    		$(this).next().slideDown({
			    complete: function(){
			        $(this).css("overflow","visible");
    			}
			});
    		elements.issue_count.not('.flagged').addClass('hide');
    		$(this).find('span.issue_counter').removeClass('hide');
   			elements.section_head.removeClass('open');
    		$(this).addClass('open');
    		elements.chevrons.removeClass('fa-rotate-90');
    		$(this).find('i').addClass('fa-rotate-90');
		},

		openProtectModal:function(event){
			mc_key = event.mc_key;
			_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi, 'modal_opened|'+Number(event.cur_id)+'']);
			$.ajax({
				url      : "/solo/question/lock?type=protect&cur_id="+event.cur_id,
				type     :'GET',
				dataType : 'html',
				success:function(response)
				{
					$(elements.content).html('').append(response);
					$('div#facebox').removeClass();
					var modal = $('.question_flag_modal div.flag_modal_container');
					clone = modal.clone();
					$.facebox(clone.show(), 'question_flag_modal');
					$('div#facebox').addClass('question_lock_modal');
					elements.acquire();
					ev.bind();
				}
			});
		},

		openPreserveModal:function(event){
			mc_key = event.mc_key;
			_gaq.push(['_trackEvent', 'lock_system', elements.params.page_lmi, 'modal_opened|'+Number(event.cur_id)+'']);
			$.ajax({
				url      : "/solo/question/lock?type=preserve&cur_id="+event.cur_id,
				type     :'GET',
				dataType : 'html',
				success:function(response)
				{
					$(elements.content).html('').append(response);
					$('div#facebox').removeClass();
					var modal = $('.question_flag_modal div.flag_modal_container');
					clone = modal.clone();
					$.facebox(clone.show(), 'question_flag_modal');
					$('div#facebox').addClass('question_lock_modal');
					$('.question_flag_modal .frame .lock_label').css({'cursor':'default'});
					elements.acquire();
					ev.bind();
				}
			});
		},

		openModal:function(event){
			mc_key = event.mc_key;
			_gaq.push(['_trackEvent', 'flag_system', elements.params.page_lmi, 'modal_opened|'+Number(event.cur_id)+'']);
			$.ajax({
				url      : "/solo/question/flag/modal/dispatcher?cur_id="+event.cur_id,
				type     :'GET',
				dataType : 'html',
				success:function(response)
				{
					$(elements.content).html('').append(response);
					$('div#facebox').removeClass();
					var modal = $('.question_flag_modal div.flag_modal_container');
					clone = modal.clone();
					$.facebox(clone.show(), 'question_flag_modal');
					added_flags = [];
					removed_flags = [];
					is_dirty = false;

					elements.acquire();
					ev.bind();

					section_heads = clone.find('.section_head');
					section_heads.each(function(){
						count = $(this).find('span.issue_counter').data('count');
						if(count == 0){
							$(this).trigger('click');
							return false;
						}
					});
				}
			});
		}
	};

	return {

		init:function(){
			elements.acquire();
			ev.bind();
			$(document).bind('open_flag_modal', ev.openModal);
			$(document).bind('open_protect_modal', ev.openProtectModal);
			$(document).bind('open_preserve_modal', ev.openPreserveModal);
		}
	};

})(jQuery);

jQuery(function($){

	question_flag_modal.init();

});


var ads_dfpslot = (function() {
	'use strict';

	var defintion = function() {

		this.attributes({
			infinite_scroll_pane_location: undefined
		});

		this.after('initialize', function() {
			if (this.attr.infinite_scroll_pane_location && carousel_mixin_infinitescroll) {
				carousel_mixin_infinitescroll.register_module({
					infinite_scroll_pane_location: this.attr.infinite_scroll_pane_location,
					height: this.attr.height || '',
					node: this.$node
				});
			}
		});
	};
	try {
		return flight.component(defintion);
	} catch(e) {
		// flight undefined
	}
})();


if(typeof mobile_swipe !== "undefined"){
	var on_interstitial = false;
	var inthtml = null;

	mobile_swipe.add_new_page_listener(function(){
		var was_on = on_interstitial,
		inner_page = mobile_swipe.current_page().find('.ad_slot'),
		jbody      = $('body');

		jbody.removeClass("full half");
		on_interstitial = inner_page.length > 0;
		if (on_interstitial){

			var current_page      = mobile_swipe.current_page();
			var current_page_idfp = current_page.children('.ads_dfpinterstitialslot');
			var interstitialdfp_ad   = jQuery('.interstitialdfp');

			/* div.interstitialdfp -- .detach and .append to the current
			.ads_dfpinterstitialslot div (current_page_idfp) */
			if(current_page_idfp.children().length === 0){
				interstitialdfp_ad.detach();
				interstitialdfp_ad.appendTo(current_page_idfp);
			}

			jbody.addClass("on_ad");

			// do whatever we need to do on firing an interstitial
			if (inner_page.hasClass("full")){
				jbody.addClass("full");
			}
			if (inner_page.hasClass("half")){
				jbody.addClass("half");
			}
		} else if (was_on) {
			// do whatever we need to do when we're done with an interstitial
			jbody.removeClass("on_ad");
		}
	});
}


!function($) {
	$('.module.utility_wrapper_card').each(function(){
		var _this = this;
		var $_this = $(_this);
		var params = $_this.data('jsparams');
		var wrapper_type = params.type;

		if(wrapper_type === "close") {
			$_this.addClass('close');
		}
                
                //check if there is an image, if not add class
                if($_this.find('.question_card_image').length === 0){
                    $_this.addClass('no_picture');
                }
	});
}(jQuery);


$('.question_card').each(function(){
	var $this = $(this);
	var question_card_params = $this.data('jsparams');

	var eles = {
		content: $this.find('div.content'),
		flagged_for_improvement: $this.find('.flagged_for_improvement button'),
		flagged_for_improvement_span: $this.find('.flagged_for_improvement button span'),
		improve_answer_container: $this.find('.improve_answer_container'),
		improve_answer_button: $this.find('.improve_answer_button'),
		share_button: $this.find('.share'),
		answer_text: $this.find('.answer_text'),
		improve_answer_container_error_message: $this.find('.improve_answer_container .error_message'),
		share_container: $this.find('.share_container'),
		ynp: $this.find('.ynp'),
		ynp_thanks: $this.find('.ynp_thanks'),
		share: $this.find('.share'),
		edit_categories: $this.find('.edit_categories'),
		original_edit_text: '',
		share_wrapper: $this.find('.share_wrapper'),
		fgroup: $this.find('.fgroup'),
		question_text			: $this.find("h1.title"),
		question_edit			: $this.find("a.pencil_mark"),
		close_edit_question		: $this.find("a.close_edit_question"),
		edit_question_box		: $this.find("div.edit_question"),
		edit_question_button	: $this.find("button.edit_question_submit"),
		merge_question_box		: $this.find("div.merge_question"),
		close_merge_question	: $this.find("a.close_merge_question"),
		new_q_merge				: $this.find("a.new_question"),
		old_q_merge				: $this.find("a.old_question"),
		merge_question_button	: $this.find("button.merge_question_submit"),
		card_overlay			: $this.find("div.card_overlay"),
		error_message			: $this.find("div.error_question_edit"),
		frame					: $this.find(".frame"),
		answer_wrapper			: $this.find(".answer_wrapper")
	};

	var functions = {
		expand_collapse: function()
		{
			if(eles.content.hasClass('collapsed'))
			{
				functions.expand();
			}
			else
			{
				functions.hide_edit_box();
				functions.collapse();
			}
		},

		expand: function()
		{
			eles.flagged_for_improvement_span.html('Hide');
			var divs = $this.find('.collapsed');
			divs.addClass('expanded');
			divs.removeClass('collapsed');
			eles.share_wrapper.removeClass('hide');
			eles.answer_text.removeClass('hide');
			eles.fgroup.removeClass('hide');
			eles.answer_wrapper.removeClass('hide');
		},

		collapse: function()
		{
			eles.flagged_for_improvement_span.html('Show');
			var divs = $this.find('.expanded');
			divs.addClass('collapsed');
			divs.removeClass('expanded');
			eles.share_wrapper.addClass('hide');
			eles.answer_text.addClass('hide');
			eles.fgroup.addClass('hide');
			eles.answer_wrapper.addClass('hide');
		},

		show_edit_box: function()
		{
			eles.improve_answer_container.show();
			eles.improve_answer_button.hide();
			eles.share_button.hide();
			eles.answer_text.hide();
			eles.original_edit_text = eles.improve_answer_container.find('.nicEdit-main').html();
		},

		hide_edit_box: function()
		{
			eles.improve_answer_container.hide();
			eles.improve_answer_button.show();
			eles.share_button.show();
			eles.answer_text.show();
		},

		reset_edit_box: function()
		{
			eles.improve_answer_container.find('.nicEdit-main').html(eles.original_edit_text);
		},

		save_answer: function()
		{
			eles.improve_answer_container_error_message.html('');
			var text = eles.improve_answer_container.find('.nicEdit-main').html();
			$.ajax({
				url      : "/solo/ajax/question/answer",
				type     :'POST',
				dataType : 'json',
				data     : {
					'answer'                : text,
					'question'              : $this.find('fieldset.improve_answer_container input[name=question_title]').val(),
					'etag'                  : $this.find('fieldset.improve_answer_container input[name=question_etag]').val(),
					'minorEdit'             : $this.find('fieldset.improve_answer_container input[name=minor_edit]').prop('checked'),
					'confirmedDeleteAnswer' : false,
					'first_answer'          : false,
					'watchThis'             : false
				},
				success:function(response)
				{
					if(response.type == 'error')
					{
						eles.improve_answer_container_error_message.html(response.error_message);
					}
					else if(response.type == 'success')
					{
						functions.hide_edit_box();
						eles.answer_text.html(text);
						eles.improve_answer_container.find('.nicEdit').html(text);
						if (response.etag)
						{
							$this.find('fieldset.improve_answer_container input[name=question_etag]').val(response.etag);
						}
					}
					else
					{
						eles.improve_answer_container_error_message.html('There was a problem trying to save your answer.');
					}
				},
				error:function(response){
					eles.improve_answer_container_error_message.html('There was a problem trying to save your answer.');
				}
			});
		},

		share : function(clicked)
		{
			var url = $(clicked).attr('data-url');
			window.open(url,'_newtab');
			// eles.share_container.hide();
		},

		ynp_submit: function(value) {
			var vote_value;
			if(value=="Yes"){
				vote_value = 1;
			}
			else if(value=="No"){
				vote_value = 3;
			}
			else{
				vote_value = 2;
			}
			$.ajax({
				url: "/solo/feedback",
				type:'POST',
				data:{
					'do':'vote',
					'depth': 0,
					'value': vote_value,
					'position': 0,
					'page': question_card_params.page,
					'mode_id': question_card_params.mode,
					'question_id': question_card_params.qid,
					'question_title': question_card_params.qtitle,
					'initial_event_type': "yesnopartial"
				},
				success: function () {
					$(document).trigger('feedback.voted', {question_id: question_card_params.qid});
				}
			});
		},

		reveal_ynp_thanks: function()
		{
			eles.ynp.addClass('hide');
			eles.ynp_thanks.removeClass('hide');
		},

		reveal_share_links: function()
		{
			eles.share_container.removeClass('hide');
		},

		hide_share_links: function()
		{
			eles.share_container.addClass('hide');
		},

		submit_merge_question: function() {
			var new_text  = eles.new_q_merge.text();
			var merge_url = question_card_params.question_merge_link + encodeURIComponent(new_text);
			$.ajax({
				url: merge_url,
				type: 'POST',
				success: function(respdata) {
					if(respdata.status == "success") {
						functions.set_question_attributes(new_text);
						functions.close_merge_question();
					}
					else {
						functions.show_error_message("Sorry, there was an error in merging the question.");
						functions.close_merge_question();
					}
				},
				error: function(data){
					functions.show_error_message(data.message);
					functions.close_merge_question();
				},
				dataType: 'json'
			});
		},

		close_merge_question: function() {
			eles.merge_question_box.hide();
			functions.close_edit_question();
		},

		submit_question_edit: function(new_text) {
			if ($.trim(new_text).length === 0) {
				functions.show_error_message('Sorry this question can not be deleted.');
				functions.close_edit_question();
				return false;
			}
			else if (question_card_params.qtitle == new_text) {
				functions.show_error_message('Please change the question text.');
				functions.close_edit_question();
				return false;
			}
			var etag = question_card_params.question_etag,
				rename_url = question_card_params.question_rename_link + encodeURIComponent(new_text);

			$.ajax({
				url: rename_url,
				type: 'POST',
				success: function(respdata) {
					if(respdata.status == "success") {
						window.location.reload();
//						functions.set_question_attributes(new_text);
//						functions.close_edit_question();
					}
					else {
						if( respdata.error_code == 409013 ) {
							eles.close_edit_question.hide();
							eles.edit_question_button.hide();
							functions.show_merge(respdata);
						}
						else {
							functions.show_error_message("Sorry, this question can not be renamed.");
							functions.close_edit_question();
						}
					}
				},
				error: function(data){
					functions.show_error_message(data.message);
					functions.close_edit_question();
				},
				dataType: 'json'
			});
		},
		show_edit_question: function() {
			eles.card_overlay.show();
			eles.edit_question_box.show();
			eles.edit_question_box.find('.new_title_text').autosize({append:"\n"});
			eles.close_edit_question.show();
			eles.edit_question_button.show();
			eles.question_edit.hide();
			eles.question_text.hide();
		},
		close_edit_question: function() {
			eles.card_overlay.hide();
			eles.edit_question_box.find('.new_title_text').val(eles.question_text.text());
			eles.edit_question_box.find('.new_title_text').autosize({append:"\n"});
			functions.change_save_button();
			eles.edit_question_box.hide();
			eles.question_edit.show();
			eles.question_text.show();
		},
		show_merge: function(respdata) {
			var q_url = question_card_params.question_url;
			q_url = q_url.replace(q_url.substr(q_url.lastIndexOf('/') + 1), '');
			// New q already exists, the question into which the old q is being merged into..

			eles.new_q_merge.text(respdata.new_q_text);
			eles.old_q_merge.text(respdata.old_q_text);
			eles.new_q_merge.attr("href", q_url + respdata.new_q_href);
			eles.old_q_merge.attr("href", q_url + respdata.old_q_href);
			eles.merge_question_box.show();
		},
		show_error_message: function(msg) {
			eles.error_message.html(msg);
			eles.error_message.removeClass('hide');
			eles.error_message.removeClass("success");
			eles.frame.addClass('contains_error');
		},
		show_success_message: function(msg) {
			eles.frame.removeClass("contains_error");
			eles.frame.addClass("success");
			eles.error_message.removeClass('hide');
			eles.error_message.html(msg);
		},
		set_question_attributes: function(new_text) {
			eles.question_text.text(new_text);
			var new_href = new_text.replace(/\ /g, "_");
			var old_href = question_card_params.qtitle.replace(/\ /g, "_");
			var re = new RegExp(old_href,"g");
			var new_link = question_card_params.question_url.replace(re, new_href);
			question_card_params.question_url = new_link;
			question_card_params.qtitle = new_text;
			eles.question_text.attr("href", new_link);
		},
		change_save_button: function(){
			var new_text = eles.frame.find('.new_title_text').val().replace(/(\?|\ )+$/gi, "");
			var old_text = eles.question_text.text().replace(/(\?|\ )+$/gi, "");
			if(old_text == new_text) {
				eles.edit_question_button.attr('asg-button','disabled');
			}
			else {
				eles.edit_question_button.attr('asg-button', "");
			}
		}
	};

	if(question_card_params.delay_textarea_fill === true){
		eles.improve_answer_container.find('.nicEdit').html(eles.answer_text.html());
		eles.improve_answer_container.find('.nicEdit-main').html(eles.answer_text.html());
	}

	eles.improve_answer_container.hide();
	eles.ynp.show();
	// eles.share_container.hide();

	eles.merge_question_button.on('click', functions.submit_merge_question);
	eles.close_merge_question.on('click', functions.close_merge_question);
	eles.question_edit.on('click', functions.show_edit_question);
	eles.close_edit_question.on('click', functions.close_edit_question);

	eles.edit_question_button.on('click', function() {
		functions.submit_question_edit( $(this).parent().parent().find('.new_title_text').val() );
	});

	eles.frame.find('.new_title_text').on('keyup', functions.change_save_button);

	eles.flagged_for_improvement.on(
		'click',
		function()
		{
			functions.expand_collapse();
		}
	);

	eles.improve_answer_button.on(
		'click',
		function()
		{
			if(eles.content.hasClass('collapsed'))
			{
				functions.expand();
			}
			functions.show_edit_box();
		}
	);

	eles.improve_answer_container.on(
		'click',
		'button.cancel',
		function()
		{
			functions.hide_edit_box();
			functions.reset_edit_box();
		}
	);

	eles.improve_answer_container.on(
		'click',
		'button.save',
		function()
		{
			functions.save_answer();
		}
	);

	eles.share.on(
		'click',
		function()
		{
			functions.reveal_share_links();
		}
	);

	eles.share_wrapper.on(
		'mouseleave',
		function(event)
		{
			functions.hide_share_links();
		}
	);

	eles.share_wrapper.on(
		'click',
		'.share_btn',
		function(event)
		{
			functions.share($(this));
		}

	);

	eles.ynp.on(
		'click',
		'button',
		function(event)
		{
			functions.ynp_submit($(this).html());
		}
	);

	eles.edit_categories.on(
		'click',
		function()
		{
			$.facebox({
				ajax: "/solo/category/selector?question_title=" + question_card_params.clean_qtitle,
			});
		}
	);


	$(document).on("feedback.voted", function(e, question) {
		if(question && question.question_id == question_card_params.qid){
			functions.reveal_ynp_thanks();
		}
	});


	if (question_card_params.show_edit == 'yes' && eles.improve_answer_button.length) {
		eles.improve_answer_button.trigger('click');
	}
});


$('.question_card_flag').each(function(){
	var $this = $(this);

	var question_card_flags_params = $this.data('jsparams');

	var eles = {
		container: 		$this.find('.flags_container'),
		flag: 			$this.find('i.fa-flag'),
		panels: 		$this.find('.accordion ul.issue_list'),
		accordion: 		$this.find('.accordion'),
		details_link: 	$this.find('.accordion section span.details_link'),
		section_head: 	$this.find('.accordion section .section_head'),
		manage_button:  $this.find('button.flag_btn'),
		protect_button: $this.find('button.protect_btn'),
		preserve_button:$this.find('button.preserve_btn'),
		no_flags_text:  $this.find('p.no_flags_text'),
		lock: 					$this.find('i.fa-lock'),
		request: 				$this.find('p.request_link'),
		unlock_form: 			$this.find('.unlock_form'),
		unlock_reason: 			$this.find('.unlock_form textarea.unlock_reason'),
		unlock_form_button: 	$this.find('.unlock_form button.unlock_send'),
		unlock_button:  		$this.find('button.unlock_button'),
		unlock_error:  			$this.find('.lock_error'),
		unlock_thanks:  		$this.find('span.unlock_thanks')
	};

	var functions = {

		show_container: function()
		{
			eles.container.removeClass("fade_then_hide");
		},

		hide_container: function()
		{
			eles.container.addClass("fade_then_hide");
		},

		open_panel : function()
		{
			if($(this).hasClass('open'))
			{
				return false;
			}

			eles.panels.slideUp();
    		$(this).next().slideDown({
			    complete: function(){
			        $(this).css("overflow","visible");
    			}
			});
    		eles.details_link.show();
   			$(this).find('span.details_link').hide();
   			eles.section_head.removeClass('open');
    		$(this).addClass('open');
    		return false;
		},

		open_modal : function()
		{
			eles.manage_button.prop("disabled", true);
			$(document).trigger({ type: 'open_flag_modal', cur_id: question_card_flags_params.cur_id, mc_key: '' });
			functions.hide_container();
			eles.manage_button.prop("disabled", false);
		},

		open_protect_modal : function()
		{
			$(document).trigger({ type: 'open_protect_modal', cur_id: question_card_flags_params.cur_id, mc_key: '' });
			functions.hide_container();
		},

		open_preserve_modal : function()
		{
			$(document).trigger({ type: 'open_preserve_modal', cur_id: question_card_flags_params.cur_id, mc_key: '' });
			functions.hide_container();
		},

		update_flags: function (event)
		{
			$('.question_card_flag .flags_container .section.' + event.flag_type).addClass('hide');

			var sections = $( '.question_card_flag .flags_container .section' ).not( ".hide" );
			if(sections.length == 0)
			{
				eles.flag.removeClass("selected");
				eles.no_flags_text.removeClass('hide');
				eles.accordion.addClass('hide')
			}
		},

		show_unlock_form: function()
		{
			eles.unlock_form.removeClass('hide');
			eles.request.addClass('hide');
		},

		unlock_question: function()
		{
			var type = $(this).data('type'),
				endpoint = type == 'protected' ? '/ajax/protectQuestion.php' : '/ajax/preserveQuestion.php';
			var data = {
			 	'title': encodeURIComponent(question_card_flags_params.title),
			 	'etag': encodeURIComponent(question_card_flags_params.etag),
			 	'jsonly': 1,
			 	'media': 'screen'
			};

			if(type == "protected"){
				data.toProtect = 0;
			}
			else{
				data.action = "unlock"
			}

			$.ajax({
				url: endpoint,
				type:'POST',
				data: data,
				dataType : 'json',
				success:function(response){
					if(response.status == 200){
						if (type == 'protected'){
							$.ajax({
								url: "/endpoint/questions/locks/reasons/delete",
								type:'POST',
								data: {
									'questions_id': question_card_flags_params.cur_id
								},
								dataType : 'json',
								success:function(response)
								{
									_gaq.push(['_trackEvent', 'lock_system', question_card_flags_params.page_lmi, 'question_unprotected', parseInt(question_card_flags_params.cur_id)]);
									_gaq.push(function() {
										location.reload();
									});
								}
							});
						}
						else {
							_gaq.push(['_trackEvent', 'lock_system', question_card_flags_params.page_lmi, 'question_unpreserved', parseInt(question_card_flags_params.cur_id)]);
							_gaq.push(function() {
								location.reload();
							});
						}
					}
					else{
						var message = 'Sorry, there was a problem unlocking the question.';
						eles.unlock_error.html(message);
					}
				},
				error:function(response){
					var message = 'Sorry, there was a problem unlocking the question.';
						eles.unlock_error.html(message);
				}
			});
		},

		send_request: function()
		{
			if (!$.trim(eles.unlock_reason.val())) {
				var message = 'Please enter a reason for unlocking this question.';
				eles.unlock_error.html(message);
				return false;
			}
			eles.unlock_error.html('');
			$.ajax({
				url: "/endpoint/questions/locks/requests/create",
				type:'POST',
				data: {
					'questions_id': question_card_flags_params.cur_id,
					'reason': $.trim(eles.unlock_reason.val())
				},
				dataType : 'json',
				success:function(response)
				{
					eles.unlock_reason.hide();
					eles.unlock_form_button.hide();
					if (response.error) {
						var message = 'Sorry, there was a problem submitting your request. Please try again later.';
						eles.unlock_error.html(message);
					} else {
						_gaq.push(['_trackEvent', 'lock_system', question_card_flags_params.page_lmi, 'unlock_requested', parseInt(question_card_flags_params.cur_id)]);

						eles.unlock_form.addClass("hide");
						eles.unlock_thanks.removeClass("hide");
					}
				}
			});
		},

		reason_keyup: function()
		{
			eles.unlock_form_button.prop('disabled',(eles.unlock_reason.val().length == 0));
		},

		manage_click: function(e)
		{
			e.stopPropagation();
			if( !eles.container.hasClass("fade_then_hide") ) {
				functions.hide_container();
			}
			else {
				functions.show_container();
			}
			$(document).trigger("flag_menu_item_clicked");
		}
	};

    eles.panels.hide().first().show();
    eles.details_link.first().hide();
    eles.section_head.first().addClass('open');

    $(document).on('update_flags', functions.update_flags);

    // Manage opening and closing of the popup..
	eles.flag.on('click', functions.manage_click);
	eles.lock.on('click', functions.manage_click);
	eles.container.on('click', function(e) {
		console.log("flag con");
		e.stopPropagation();
	});
	$("body").on('click', function() {
		functions.hide_container();
	});

	$(document).on("trash_menu_item_clicked",function(){
		functions.hide_container();
	});

	// ends.

	eles.request.on('click', functions.show_unlock_form);
	eles.unlock_button.on('click', functions.unlock_question);
	eles.unlock_reason.on('keyup', functions.reason_keyup);
	eles.unlock_form_button.on('click', functions.send_request);
	eles.section_head.on('click', functions.open_panel);
	eles.manage_button.on('click', functions.open_modal);
	eles.protect_button.on('click', functions.open_protect_modal);
	eles.preserve_button.on('click', functions.open_preserve_modal);
});


var question_card_share = (function($){

	var elements = {
		acquire:function() {
			this.share_btn = $('.question_card_share .share_btn');
		}
	};

	var ev = {
		bind:function(){
			elements.share_btn.bind('click',ev.shareClick);
		},

		shareClick:function(e){
			var url = $(this).attr('data-url');
			window.open(url,'_newtab');
		}
	};
	
	return {

		init:function(){
			elements.acquire();
			ev.bind();
		}
	};

})(jQuery);

jQuery(function($){

	question_card_share.init();

});

$('.question_card_categories').each(function(){
	var $this = $(this);
	var question_card_categories_params = $this.data('jsparams');

	var eles = {
		edit_categories: $this.find('.edit_categories')
	};

	eles.edit_categories.on(
		'click',
		function() {
			$.facebox({
				ajax:'/solo/category/selector?question_title=' + question_card_categories_params.qtitle
			});
		}
	);
});


$('.question_title').each(function(){
	var $this = $(this);
	var question_title_params = $this.data('jsparams');

	var eles = {
		question_text			: $this.find("h1.title span.title_text"),
		question_edit			: $this.find("a.pencil_mark"),
		close_edit_question		: $this.find("a.close_edit_question"),
		edit_question_box		: $this.find("div.edit_question"),
		edit_question_button	: $this.find("button.edit_question_submit"),
		merge_question_box		: $this.find("div.merge_question"),
		close_merge_question	: $this.find("a.close_merge_question"),
		new_q_merge				: $this.find("a.new_question"),
		old_q_merge				: $this.find("a.old_question"),
		merge_question_button	: $this.find("button.merge_question_submit"),
		card_overlay			: $this.find("div.card_overlay"),
		error_message			: $this.find("div.error_message"),
		wrapper					: $this.find(".title_edit_wrapper"),
		merge_question_buttons 	: $this.find(".merge_question_buttons")
	};

	var functions = {
		
		submit_merge_question: function() {
			var params = {
				'primary_q'   : eles.new_q_merge.text(),
				'alternate_q' : eles.old_q_merge.text()
			};

			$.ajax({
				url      : '/endpoint/questions/merge',
				type     : 'POST',
				data     : params,
				dataType : 'json',
				success: function(respdata) {
					if(respdata.error)
					{
						functions.show_error_message(respdata.error);
					}
					else if(respdata.result)
					{
						window.location.reload();
					}
				}
			});
		},

		close_merge_question: function() {
			eles.merge_question_box.hide();
			eles.merge_question_buttons.hide();
			eles.close_edit_question.show();
			eles.edit_question_button.show();
		},

		submit_question_edit: function(new_text) {
			eles.error_message.addClass("hide");
			if ($.trim(new_text).length === 0) {
				functions.show_error_message('Sorry this question can not be deleted.');
				functions.close_edit_question();
				return false;
			}
			else if (question_title_params.qtitle == new_text) {
				functions.show_error_message('Please change the question text.');
				functions.close_edit_question();
				return false;
			}
			var etag = question_title_params.question_etag,
				rename_url = question_title_params.question_rename_link + encodeURIComponent(new_text);

			$.ajax({
				url: rename_url,
				type: 'POST',
				success: function(respdata) {
					if(respdata.status == "success") {
						window.location.reload();
//						functions.set_question_attributes(new_text);
//						functions.close_edit_question();
//						$(document).trigger({ type: 'update_flags', flag_type: 'question' });
					}
					else {
						if( respdata.error_code == 409013 ) {
							eles.close_edit_question.hide();
							eles.edit_question_button.hide();
							functions.show_merge(respdata);
						}
						else if( respdata.error_code == 409019 ) {
							functions.show_error_message(respdata.message+" '"+respdata.new_primary_q_href.split("_").join(" ")+"'");
						}
						else {
							var details = (respdata.message != 'undefined') ? respdata.message : "";
							functions.show_error_message("Sorry, this question can not be renamed. "+respdata.message);
						}
					}
				},
				error: function(data){
					functions.show_error_message(data.message);
				},
				dataType: 'json'
			});
		},
		show_edit_question: function() {
			eles.card_overlay.show();
			eles.edit_question_box.show();
			//eles.edit_question_box.find('.new_title_text').autosize({append:"\n"});
			eles.close_edit_question.show();
			eles.edit_question_button.show();
			eles.question_edit.hide();
			eles.question_text.hide();
		},
		close_edit_question: function() {
			eles.card_overlay.hide();
			eles.edit_question_box.find('.new_title_text').val(eles.question_text.text());
			//eles.edit_question_box.find('.new_title_text').autosize({append:"\n"});
			functions.change_save_button();
			eles.edit_question_box.hide();
			eles.question_edit.show();
			eles.question_text.show();
			eles.error_message.addClass("hide");
		},
		show_merge: function(respdata) {
			var q_url = question_title_params.question_url;
			q_url = q_url.replace(q_url.substr(q_url.lastIndexOf('/') + 1), '');
			// New q already exists, the question into which the old q is being merged into..
			eles.merge_question_buttons.show();
			eles.new_q_merge.text(respdata.new_q_text);
			eles.old_q_merge.text(respdata.old_q_text);
			eles.new_q_merge.attr("href", q_url + respdata.new_q_href);
			eles.old_q_merge.attr("href", q_url + respdata.old_q_href);
			eles.merge_question_box.show();
		},
		show_error_message: function(msg) {
			eles.error_message.html(msg);
			eles.error_message.removeClass('hide');
			eles.error_message.removeClass("success");
			eles.wrapper.addClass('contains_error');
		},
		show_success_message: function(msg) {
			eles.wrapper.removeClass("contains_error");
			eles.wrapper.addClass("success");
			eles.error_message.removeClass('hide');
			eles.error_message.html(msg);
		},
		set_question_attributes: function(new_text) {
			eles.question_text.text(new_text);
			var new_href = new_text.replace(/\ /g, "_");
			var old_href = question_title_params.qtitle.replace(/\ /g, "_");
			var re = new RegExp(old_href,"g");
			var new_link = question_title_params.question_url.replace(re, new_href);
			question_title_params.question_url = new_link;
			question_title_params.qtitle = new_text;
			eles.question_text.attr("href", new_link);
		},
		change_save_button: function(){
			var new_text = eles.wrapper.find('.new_title_text').val().replace(/(\?|\ )+$/gi, "");
			var old_text = eles.question_text.text().replace(/(\?|\ )+$/gi, "");

			if(old_text == new_text) {
				eles.edit_question_button.attr('asg-button','disabled');
			}
			else {
				eles.edit_question_button.attr('asg-button', "");
			}
		}
	};

	eles.merge_question_button.on('click', functions.submit_merge_question);
	eles.close_merge_question.on('click', functions.close_merge_question);
	eles.question_edit.on('click', functions.show_edit_question);
	eles.close_edit_question.on('click', functions.close_edit_question);
	eles.edit_question_button.on('click', function() {
		functions.submit_question_edit( $(this).parent().parent().find('.new_title_text').val() );
	});
	eles.wrapper.find('.new_title_text').on('keyup', functions.change_save_button);
});


/* NicEdit - Micro Inline WYSIWYG
 * Copyright 2007-2008 Brian Kirchoff
 *
 * NicEdit is distributed under the terms of the MIT license
 * For more information visit http://nicedit.com/
 * Do not remove this copyright message
 */
var bkExtend = function(){
	var args = arguments;
	if (args.length == 1) args = [this, args[0]];
	for (var prop in args[1]) args[0][prop] = args[1][prop];
	return args[0];
};
function bkClass() { }
bkClass.prototype.construct = function() {};
bkClass.extend = function(def) {
  var classDef = function() {
      if (arguments[0] !== bkClass) { return this.construct.apply(this, arguments); }
  };
  var proto = new this(bkClass);
  bkExtend(proto,def);
  classDef.prototype = proto;
  classDef.extend = this.extend;
  return classDef;
};

var bkElement = bkClass.extend({
	construct : function(elm,d) {
		if(typeof(elm) == "string") {
			elm = (d || document).createElement(elm);
		}
		elm = $BK(elm);
		return elm;
	},

	appendTo : function(elm) {
		elm.appendChild(this);
		return this;
	},

	appendBefore : function(elm) {
		elm.parentNode.insertBefore(this,elm);
		return this;
	},

	addEvent : function(type, fn) {
		bkLib.addEvent(this,type,fn);
		return this;
	},

	setContent : function(c) {
		this.innerHTML = c;
		return this;
	},

	pos : function() {
		var curleft = curtop = 0;
		var o = obj = this;
		if (obj.offsetParent) {
			do {
				curleft += obj.offsetLeft;
				curtop += obj.offsetTop;
			} while (obj = obj.offsetParent);
		}
		var b = (!window.opera) ? parseInt(this.getStyle('border-width') || this.style.border) || 0 : 0;
		return [curleft+b,curtop+b+this.offsetHeight];
	},

	noSelect : function() {
		bkLib.noSelect(this);
		return this;
	},

	parentTag : function(t) {
		var elm = this;
		 do {
			if(elm && elm.nodeName && elm.nodeName.toUpperCase() == t) {
				return elm;
			}
			elm = elm.parentNode;
		} while(elm);
		return false;
	},

	hasClass : function(cls) {
		return this.className.match(new RegExp('(\\s|^)nicEdit-'+cls+'(\\s|$)'));
	},

	addClass : function(cls) {
		if (!this.hasClass(cls)) { this.className += " nicEdit-"+cls };
		return this;
	},

	removeClass : function(cls) {
		if (this.hasClass(cls)) {
			this.className = this.className.replace(new RegExp('(\\s|^)nicEdit-'+cls+'(\\s|$)'),' ');
		}
		return this;
	},

	setStyle : function(st) {
		var elmStyle = this.style;
		for(var itm in st) {
			switch(itm) {
				case 'float':
					elmStyle['cssFloat'] = elmStyle['styleFloat'] = st[itm];
					break;
				case 'opacity':
					elmStyle.opacity = st[itm];
					elmStyle.filter = "alpha(opacity=" + Math.round(st[itm]*100) + ")";
					break;
				case 'className':
					this.className = st[itm];
					break;
				default:
					if(document.compatMode || itm != "cursor") { // Nasty Workaround for IE 5.5
						elmStyle[itm] = st[itm];
					}
			}
		}
		return this;
	},

	getStyle : function( cssRule, d ) {
		var doc = (!d) ? document.defaultView : d;
		if(this.nodeType == 1)
		return (doc && doc.getComputedStyle) ? doc.getComputedStyle( this, null ).getPropertyValue(cssRule) : this.currentStyle[ bkLib.camelize(cssRule) ];
	},

	remove : function() {
		this.parentNode.removeChild(this);
		return this;
	},

	setAttributes : function(at) {
		for(var itm in at) {
			this[itm] = at[itm];
		}
		return this;
	}
});

var bkLib = {
	isMSIE : (navigator.appVersion.indexOf("MSIE") != -1),

	addEvent : function(obj, type, fn) {
		(obj.addEventListener) ? obj.addEventListener( type, fn, false ) : obj.attachEvent("on"+type, fn);
	},

	toArray : function(iterable) {
		var length = iterable.length, results = new Array(length);
    	while (length--) { results[length] = iterable[length] };
    	return results;
	},

	noSelect : function(element) {
		if(element.setAttribute && element.nodeName.toLowerCase() != 'input' && element.nodeName.toLowerCase() != 'textarea') {
			element.setAttribute('unselectable','on');
		}
		for(var i=0;i<element.childNodes.length;i++) {
			bkLib.noSelect(element.childNodes[i]);
		}
	},
	camelize : function(s) {
		return s.replace(/\-(.)/g, function(m, l){return l.toUpperCase()});
	},
	inArray : function(arr,item) {
	    return (bkLib.search(arr,item) != null);
	},
	search : function(arr,itm) {
		for(var i=0; i < arr.length; i++) {
			if(arr[i] == itm)
				return i;
		}
		return null;
	},
	cancelEvent : function(e) {
		e = e || window.event;
		if(e.preventDefault && e.stopPropagation) {
			e.preventDefault();
			e.stopPropagation();
		}
		return false;
	},
	domLoad : [],
	domLoaded : function() {
		if (arguments.callee.done) return;
		arguments.callee.done = true;
		for (i = 0;i < bkLib.domLoad.length;i++) bkLib.domLoad[i]();
	},
	onDomLoaded : function(fireThis) {
		this.domLoad.push(fireThis);
		if (document.addEventListener) {
			document.addEventListener("DOMContentLoaded", bkLib.domLoaded, null);
		} else if(bkLib.isMSIE) {
			document.write("<style>.nicEdit-main p { margin: 0; }</style><scr"+"ipt id=__ie_onload defer " + ((location.protocol == "https:") ? "src='javascript:void(0)'" : "src=//0") + "><\/scr"+"ipt>");
			$BK("__ie_onload").onreadystatechange = function() {
			    if (this.readyState == "complete"){bkLib.domLoaded();}
			};
		}
	    window.onload = bkLib.domLoaded;
	}
};

function $BK(elm) {
	if(typeof(elm) == "string") {
		elm = document.getElementById(elm);
	}
	return (elm && !elm.appendTo) ? bkExtend(elm,bkElement.prototype) : elm;
}

var bkEvent = {
	addEvent : function(evType, evFunc) {
		if(evFunc) {
			this.eventList = this.eventList || {};
			this.eventList[evType] = this.eventList[evType] || [];
			this.eventList[evType].push(evFunc);
		}
		return this;
	},
	fireEvent : function() {
		var args = bkLib.toArray(arguments), evType = args.shift();
		if(this.eventList && this.eventList[evType]) {
			for(var i=0;i<this.eventList[evType].length;i++) {
				this.eventList[evType][i].apply(this,args);
			}
		}
	}
};

function __(s) {
	return s;
}

Function.prototype.closure = function() {
  var __method = this, args = bkLib.toArray(arguments), obj = args.shift();
  return function() { if(typeof(bkLib) != 'undefined') { return __method.apply(obj,args.concat(bkLib.toArray(arguments))); } };
}

Function.prototype.closureListener = function() {
  	var __method = this, args = bkLib.toArray(arguments), object = args.shift();
  	return function(e) {
  	e = e || window.event;
  	if(e.target) { var target = e.target; } else { var target =  e.srcElement };
	  	return __method.apply(object, [e,target].concat(args) );
	};
}


/* START CONFIG */

var nicEditorConfig = bkClass.extend({
	buttons : {
		'bold' : {name : __('Click to Bold'), command : 'Bold', tags : ['B','STRONG'], css : {'font-weight' : 'bold'}, key : 'b'},
		'italic' : {name : __('Click to Italic'), command : 'Italic', tags : ['EM','I'], css : {'font-style' : 'italic'}, key : 'i'},
		'underline' : {name : __('Click to Underline'), command : 'Underline', tags : ['U'], css : {'text-decoration' : 'underline'}, key : 'u'},
		'left' : {name : __('Left Align'), command : 'justifyleft', noActive : true},
		'center' : {name : __('Center Align'), command : 'justifycenter', noActive : true},
		'right' : {name : __('Right Align'), command : 'justifyright', noActive : true},
		'justify' : {name : __('Justify Align'), command : 'justifyfull', noActive : true},
		'ol' : {name : __('Insert Ordered List'), command : 'insertorderedlist', tags : ['OL']},
		'ul' : 	{name : __('Insert Unordered List'), command : 'insertunorderedlist', tags : ['UL']},
		'subscript' : {name : __('Click to Subscript'), command : 'subscript', tags : ['SUB']},
		'superscript' : {name : __('Click to Superscript'), command : 'superscript', tags : ['SUP']},
		'strikethrough' : {name : __('Click to Strike Through'), command : 'strikeThrough', css : {'text-decoration' : 'line-through'}},
		'removeformat' : {name : __('Remove Formatting'), command : 'removeformat', noActive : true},
		'indent' : {name : __('Indent Text'), command : 'indent', noActive : true},
		'outdent' : {name : __('Remove Indent'), command : 'outdent', noActive : true},
		'hr' : {name : __('Horizontal Rule'), command : 'insertHorizontalRule', noActive : true}
	},
	iconsPath : '//file.answcdn.com/answ-cld/image/upload/v1419003125/nicedit/r05irtmjni1llisl5g1s.gif',
	buttonList : ['save','bold','italic','underline','left','center','right','justify','ol','ul','fontSize','fontFamily','fontFormat','indent','outdent','image','upload','link','unlink','forecolor','bgcolor','youtube'],
	iconList : {
		"bgcolor":1,
		"forecolor":2,
		"bold":3,
		"center":4,
		"hr":5,
		"indent":6,
		"italic":7,
		"justify":8,
		"left":9,
		"ol":10,
		"outdent":11,
		"removeformat":12,
		"right":13,
		"save":24,
		"strikethrough":15,
		"subscript":16,
		"superscript":17,
		"ul":18,
		"underline":19,
		"image":20,
		"link":21,
		"unlink":22,
		"close":23,
		"arrow":25,
		"youtube":26
	},
	faIconList : {
		"bgcolor"		: "fa-tint",
		"forecolor"		: "fa-pencil-square-o",
		"bold"			: "fa-bold",
		"center"		: "fa-align-center",
		"hr"			: "fa-minus",
		"indent"		: "fa-indent",
		"italic"		: "fa-italic",
		"justify"		: "fa-align-justify",
		"left"			: "fa-align-left",
		"ol"			: "fa-list-ol",
		"outdent"		: "fa-outdent",
		"removeformat"	: "fa-undo",
		"right"			: "fa-align-right",
		"save"			: "fa-floppy-o",
		"strikethrough"	: "fa-strikethrough",
		"subscript"		: "fa-subscript",
		"superscript"	: "fa-superscript",
		"ul"			: "fa-list-ul",
		"underline"		: "fa-underline",
		"image"			: "fa-picture-o",
		"link"			: "fa-link",
		"unlink"		: "fa-chain-broken",
		"close"			: "fa-times",
		"arrow"			: "fa-caret-down",
		"youtube"		: "fa-video-camera"
	}


});
/* END CONFIG */


var nicEditors = {
	nicPlugins : [],
	editors : [],

	registerPlugin : function(plugin,options) {
		this.nicPlugins.push({p : plugin, o : options});
	},

	allTextAreas : function(nicOptions) {
		var textareas = document.getElementsByTagName("textarea");
		for(var i=0;i<textareas.length;i++) {
			nicEditors.editors.push(new nicEditor(nicOptions).panelInstance(textareas[i]));
		}
		return nicEditors.editors;
	},

	findEditor : function(e) {
		var editors = nicEditors.editors;
		for(var i=0;i<editors.length;i++) {
			if(editors[i].instanceById(e)) {
				return editors[i].instanceById(e);
			}
		}
	}
};


var nicEditor = bkClass.extend({
	construct : function(o) {
		this.options = new nicEditorConfig();
		bkExtend(this.options,o);
		this.nicInstances = new Array();
		this.loadedPlugins = new Array();

		var plugins = nicEditors.nicPlugins;
		for(var i=0;i<plugins.length;i++) {
			this.loadedPlugins.push(new plugins[i].p(this,plugins[i].o));
		}
		nicEditors.editors.push(this);
		bkLib.addEvent(document.body,'mousedown', this.selectCheck.closureListener(this) );
	},

	panelInstance : function(e,o) {
		e = this.checkReplace($BK(e));
		var panelElm = new bkElement('DIV').appendBefore(e);
		this.setPanel(panelElm);
		return this.addInstance(e,o);
	},

	checkReplace : function(e) {
		var r = nicEditors.findEditor(e);
		if(r) {
			r.removeInstance(e);
			r.removePanel();
		}
		return e;
	},

	addInstance : function(e,o) {
		e = this.checkReplace($BK(e));
		if( e.contentEditable || !!window.opera ) {
			var newInstance = new nicEditorInstance(e,o,this);
		} else {
			var newInstance = new nicEditorIFrameInstance(e,o,this);
		}
		this.nicInstances.push(newInstance);
		return this;
	},

	removeInstance : function(e) {
		e = $BK(e);
		var instances = this.nicInstances;
		for(var i=0;i<instances.length;i++) {
			if(instances[i].e == e) {
				instances[i].remove();
				this.nicInstances.splice(i,1);
			}
		}
	},

	removePanel : function(e) {
		if(this.nicPanel) {
			this.nicPanel.remove();
			this.nicPanel = null;
		}
	},

	instanceById : function(e) {
		e = $BK(e);
		var instances = this.nicInstances;
		for(var i=0;i<instances.length;i++) {
			if(instances[i].e == e) {
				return instances[i];
			}
		}
	},

	setPanel : function(e) {
		this.nicPanel = new nicEditorPanel($BK(e),this.options,this);
		this.fireEvent('panel',this.nicPanel);
		return this;
	},

	nicCommand : function(cmd,args) {
		if(this.selectedInstance) {
			this.selectedInstance.nicCommand(cmd,args);
		}
	},

	getIcon : function(iconName,options) {
		var faIcon = this.options.faIconList[iconName];
		var icon = this.options.iconList[iconName];
		var file = (options.iconFiles) ? options.iconFiles[iconName] : '';
		if(faIcon){
			return "<i class='fa " + faIcon + "'></i>";
		}
		return {backgroundImage : "url('"+((icon) ? this.options.iconsPath : file)+"')", backgroundPosition : ((icon) ? ((icon-1)*-18) : 0)+'px 0px'};
	},

	selectCheck : function(e,t) {
		var found = false;
		do{
			if(t.className && t.className.indexOf('nicEdit') != -1) {
				return false;
			}
		} while(t = t.parentNode);
		this.fireEvent('blur',this.selectedInstance,t);
		this.lastSelectedInstance = this.selectedInstance;
		this.selectedInstance = null;
		return false;
	}

});
nicEditor = nicEditor.extend(bkEvent);


var nicEditorInstance = bkClass.extend({
	isSelected : false,

	construct : function(e,options,nicEditor) {
		this.ne = nicEditor;
		this.elm = this.e = e;
		this.options = options || {};

		newX = parseInt(e.getStyle('width')) || e.clientWidth;
		newY = parseInt(e.getStyle('height')) || e.clientHeight;
		this.initialHeight = newY-8;

		var isTextarea = (e.nodeName.toLowerCase() == "textarea");
		if(isTextarea || this.options.hasPanel) {
			var ie7s = (bkLib.isMSIE && !((typeof document.body.style.maxHeight != "undefined") && document.compatMode == "CSS1Compat"))
			var s = {};
			s[(ie7s) ? 'height' : 'maxHeight'] = (this.ne.options.maxHeight) ? this.ne.options.maxHeight+'px' : null;
			this.editorContain = new bkElement('DIV').setStyle(s).addClass('mainContain').appendBefore(e);
            var editorElm = new bkElement('DIV').setStyle({minHeight : newY+'px'}).addClass('main').appendTo(this.editorContain);

			e.setStyle({display : 'none'});

			editorElm.innerHTML = e.innerHTML;
			if(isTextarea) {
				editorElm.setContent(e.value);
				this.copyElm = e;
				var f = e.parentTag('FORM');
				if(f) { bkLib.addEvent( f, 'submit', this.saveContent.closure(this)); }
			}
			editorElm.setStyle((ie7s) ? {height : newY+'px'} : {overflow: 'hidden'});
			this.elm = editorElm;
		}
		this.ne.addEvent('blur',this.blur.closure(this));

		this.init();
		this.blur();
	},

	init : function() {
		this.elm.setAttribute('contentEditable','true');
		if(this.getContent() == "") {
			this.setContent('<br />');
		}
		this.instanceDoc = document.defaultView;
		this.elm.addEvent('mousedown',this.selected.closureListener(this)).addEvent('keypress',this.keyDown.closureListener(this)).addEvent('focus',this.selected.closure(this)).addEvent('blur',this.blur.closure(this)).addEvent('keyup',this.selected.closure(this));
		this.ne.fireEvent('add',this);
	},

	remove : function() {
		this.saveContent();
		if(this.copyElm || this.options.hasPanel) {
			this.editorContain.remove();
			this.e.setStyle({'display' : 'block'});
			this.ne.removePanel();
		}
		this.disable();
		this.ne.fireEvent('remove',this);
	},

	disable : function() {
		this.elm.setAttribute('contentEditable','false');
	},

	getSel : function() {
		return (window.getSelection) ? window.getSelection() : document.selection;
	},

	getRng : function() {
		var s = this.getSel();
		if(!s || s.rangeCount === 0) { return; }
		return (s.rangeCount > 0) ? s.getRangeAt(0) : s.createRange();
	},

	selRng : function(rng,s) {
		if(window.getSelection) {
			s.removeAllRanges();
			s.addRange(rng);
		} else {
			rng.select();
		}
	},

	selElm : function() {
		var r = this.getRng();
		if(!r) { return; }
		if(r.startContainer) {
			var contain = r.startContainer;
			if(r.cloneContents().childNodes.length == 1) {
				for(var i=0;i<contain.childNodes.length;i++) {
					var rng = contain.childNodes[i].ownerDocument.createRange();
					rng.selectNode(contain.childNodes[i]);
					if(r.compareBoundaryPoints(Range.START_TO_START,rng) != 1 &&
						r.compareBoundaryPoints(Range.END_TO_END,rng) != -1) {
						return $BK(contain.childNodes[i]);
					}
				}
			}
			return $BK(contain);
		} else {
			return $BK((this.getSel().type == "Control") ? r.item(0) : r.parentElement());
		}
	},

	saveRng : function() {
		this.savedRange = this.getRng();
		this.savedSel = this.getSel();
	},

	restoreRng : function() {
		if(this.savedRange) {
			this.selRng(this.savedRange,this.savedSel);
		}
	},

	keyDown : function(e,t) {
		$(document).trigger("nicEdit_key_down",t);
		if(e.ctrlKey) {
			this.ne.fireEvent('key',this,e);
		}
	},

	selected : function(e,t) {
		if(!t && !(t = this.selElm)) { t = this.selElm(); }
		if(!e.ctrlKey) {
			var selInstance = this.ne.selectedInstance;
			if(selInstance != this) {
				if(selInstance) {
					this.ne.fireEvent('blur',selInstance,t);
				}
				this.ne.selectedInstance = this;
				this.ne.fireEvent('focus',selInstance,t);
			}
			this.ne.fireEvent('selected',selInstance,t);
			this.isFocused = true;
			this.elm.addClass('selected');
		}
		return false;
	},

	blur : function() {
		this.isFocused = false;
		this.elm.removeClass('selected');
	},

	saveContent : function() {
		if(this.copyElm || this.options.hasPanel) {
			this.ne.fireEvent('save',this);
			(this.copyElm) ? this.copyElm.value = this.getContent() : this.e.innerHTML = this.getContent();
		}
	},

	getElm : function() {
		return this.elm;
	},

	getContent : function() {
		this.content = this.getElm().innerHTML;
		this.ne.fireEvent('get',this);
		return this.content;
	},

	setContent : function(e) {
		this.content = e;
		this.ne.fireEvent('set',this);
		this.elm.innerHTML = this.content;
	},

	nicCommand : function(cmd,args) {
		document.execCommand(cmd,false,args);
	}
});

var nicEditorIFrameInstance = nicEditorInstance.extend({
	savedStyles : [],

	init : function() {
		var c = this.elm.innerHTML.replace(/^\s+|\s+$/g, '');
		this.elm.innerHTML = '';
		(!c) ? c = "<br />" : c;
		this.initialContent = c;

		this.elmFrame = new bkElement('iframe').setAttributes({'src' : 'javascript:;', 'frameBorder' : 0, 'allowTransparency' : 'true', 'scrolling' : 'no'}).setStyle({height: '100px', width: '100%'}).addClass('frame').appendTo(this.elm);

		if(this.copyElm) { this.elmFrame.setStyle({width : (this.elm.offsetWidth-4)+'px'}); }

		var styleList = ['font-size','font-family','font-weight','color'];
		for(itm in styleList) {
			this.savedStyles[bkLib.camelize(itm)] = this.elm.getStyle(itm);
		}

		setTimeout(this.initFrame.closure(this),50);
	},

	disable : function() {
		this.elm.innerHTML = this.getContent();
	},

	initFrame : function() {
		var fd = $BK(this.elmFrame.contentWindow.document);
		fd.designMode = "on";
		fd.open();
		var css = this.ne.options.externalCSS;
		fd.write('<html><head>'+((css) ? '<link href="'+css+'" rel="stylesheet" type="text/css" />' : '')+'</head><body id="nicEditContent" style="margin: 0 !important; background-color: transparent !important;">'+this.initialContent+'</body></html>');
		fd.close();
		this.frameDoc = fd;

		this.frameWin = $BK(this.elmFrame.contentWindow);
		this.frameContent = $BK(this.frameWin.document.body).setStyle(this.savedStyles);
		this.instanceDoc = this.frameWin.document.defaultView;

		this.heightUpdate();
		this.frameDoc.addEvent('mousedown', this.selected.closureListener(this)).addEvent('keyup',this.heightUpdate.closureListener(this)).addEvent('keydown',this.keyDown.closureListener(this)).addEvent('keyup',this.selected.closure(this));
		this.ne.fireEvent('add',this);
	},

	getElm : function() {
		return this.frameContent;
	},

	setContent : function(c) {
		this.content = c;
		this.ne.fireEvent('set',this);
		this.frameContent.innerHTML = this.content;
		this.heightUpdate();
	},

	getSel : function() {
		return (this.frameWin) ? this.frameWin.getSelection() : this.frameDoc.selection;
	},

	heightUpdate : function() {
		this.elmFrame.style.height = Math.max(this.frameContent.offsetHeight,this.initialHeight)+'px';
	},

	nicCommand : function(cmd,args) {
		this.frameDoc.execCommand(cmd,false,args);
		setTimeout(this.heightUpdate.closure(this),100);
	}


});
var nicEditorPanel = bkClass.extend({
	construct : function(e,options,nicEditor) {
		this.elm = e;
		this.options = options;
		this.ne = nicEditor;
		this.panelButtons = new Array();
		this.buttonList = bkExtend([],this.ne.options.buttonList);

		this.panelContain = new bkElement('DIV').addClass('panelContain');
		this.panelElm = new bkElement('DIV').addClass('panel').appendTo(this.panelContain);
		this.panelContain.appendTo(e);

		var opt = this.ne.options;
		var buttons = opt.buttons;
		for(button in buttons) {
				this.addButton(button,opt,true);
		}
		this.reorder();
		e.noSelect();
	},

	addButton : function(buttonName,options,noOrder) {
		var button = options.buttons[buttonName];
		var type = (button['type']) ? eval('(typeof('+button['type']+') == "undefined") ? null : '+button['type']+';') : nicEditorButton;
		var hasButton = bkLib.inArray(this.buttonList,buttonName);
		if(type && (hasButton || this.ne.options.fullPanel)) {
			this.panelButtons.push(new type(this.panelElm,buttonName,options,this.ne));
			if(!hasButton) {
				this.buttonList.push(buttonName);
			}
		}
	},

	findButton : function(itm) {
		for(var i=0;i<this.panelButtons.length;i++) {
			if(this.panelButtons[i].name == itm)
				return this.panelButtons[i];
		}
	},

	reorder : function() {
		var bl = this.buttonList;
		for(var i=0;i<bl.length;i++) {
			var button = this.findButton(bl[i]);
			if(button) {
				this.panelElm.appendChild(button.margin);
			}
		}
	},

	remove : function() {
		this.elm.remove();
	}
});
var nicEditorButton = bkClass.extend({

	construct : function(e,buttonName,options,nicEditor) {
		this.options = options.buttons[buttonName];
		this.name = buttonName;
		this.ne = nicEditor;
		this.elm = e;

		this.margin = new bkElement('DIV').addClass('buttonWrapper').appendTo(e);
		this.contain = new bkElement('DIV').addClass('buttonContain').appendTo(this.margin);
		this.border = new bkElement('DIV').addClass('button-border').appendTo(this.contain);
		this.button = new bkElement('DIV').addClass('button').setContent(this.ne.getIcon(buttonName,options)).appendTo(this.border);
		this.button.addEvent('mouseover', this.hoverOn.closure(this)).addEvent('mouseout',this.hoverOff.closure(this)).addEvent('mousedown',this.mouseClick.closure(this)).noSelect();

		if(!window.opera) {
			this.button.onmousedown = this.button.onclick = bkLib.cancelEvent;
		}

		nicEditor.addEvent('selected', this.enable.closure(this)).addEvent('blur', this.disable.closure(this)).addEvent('key',this.key.closure(this));

		this.disable();
		this.init();
	},

	init : function() {  },

	hide : function() {
		this.contain.setStyle({display : 'none'});
	},

	checkNodes : function(e) {
		var elm = e;
		do {
			if(this.options.tags && bkLib.inArray(this.options.tags,elm.nodeName)) {
				this.activate();
				return true;
			}
		} while(elm = elm.parentNode && elm.className != "nicEdit");
		elm = $BK(e);
		while(elm.nodeType == 3) {
			elm = $BK(elm.parentNode);
		}
		if(this.options.css) {
			for(itm in this.options.css) {
				if(elm.getStyle(itm,this.ne.selectedInstance.instanceDoc) == this.options.css[itm]) {
					this.activate();
					return true;
				}
			}
		}
		this.deactivate();
		return false;
	},

	activate : function() {
		if(!this.isDisabled) {
			this.isActive = true;
			this.border.addClass("button_active");
			this.ne.fireEvent('buttonActivate',this);
		}
	},

	deactivate : function() {
		this.isActive = false;
		this.border.removeClass("button_active");
		if(!this.isDisabled) {
			this.ne.fireEvent('buttonDeactivate',this);
		}
	},

	enable : function(ins,t) {
		this.isDisabled = false;
		this.contain.addClass('buttonEnabled');
		this.checkNodes(t);
	},

	disable : function(ins,t) {
		this.isDisabled = true;
		this.contain.removeClass('buttonEnabled');
	},

	toggleActive : function() {
		(this.isActive) ? this.deactivate() : this.activate();
	},

	hoverOn : function() {
		if(!this.isDisabled) {
			this.isHover = true;
			this.ne.fireEvent("buttonOver",this);
		}
	},

	hoverOff : function() {
		this.isHover = false;
		this.ne.fireEvent("buttonOut",this);
	},

	mouseClick : function() {
		if(this.options.command) {
			this.ne.nicCommand(this.options.command,this.options.commandArgs);
			if(!this.options.noActive) {
				this.toggleActive();
			}
		}
		this.ne.fireEvent("buttonClick",this);
	},

	key : function(nicInstance,e) {
		if(this.options.key && e.ctrlKey && String.fromCharCode(e.keyCode || e.charCode).toLowerCase() == this.options.key) {
			this.mouseClick();
			if(e.preventDefault) e.preventDefault();
		}
	}

});


var nicPlugin = bkClass.extend({

	construct : function(nicEditor,options) {
		this.options = options;
		this.ne = nicEditor;
		this.ne.addEvent('panel',this.loadPanel.closure(this));

		this.init();
	},

	loadPanel : function(np) {
		var buttons = this.options.buttons;
		for(var button in buttons) {
			np.addButton(button,this.options);
		}
		np.reorder();
	},

	init : function() {  }
});




 /* START CONFIG */
var nicPaneOptions = { };
/* END CONFIG */

var nicEditorPane = bkClass.extend({
	construct : function(elm,nicEditor,options,openButton,className) {
		this.ne = nicEditor;
		this.elm = elm;
		this.pos = elm.pos();

		this.contain = new bkElement('div').setStyle({left : this.pos[0]+'px', top : this.pos[1]+'px'}).addClass('paneWrapper');
		if(className){
			this.contain.addClass(className);
		}
		this.arrow_span = new bkElement('span').addClass('paneArrow').appendTo(this.contain);
		this.pane = new bkElement('div').addClass('pane').setStyle(options).appendTo(this.contain);

		if(openButton && !openButton.options.noClose) {
			this.close = new bkElement('div').addClass('paneClose').setContent(this.ne.getIcon('close',nicPaneOptions)).addEvent('mousedown',openButton.removePane.closure(this)).appendTo(this.pane);
		}

		this.contain.noSelect().appendTo(document.body);

		this.position();
		this.init();
	},

	init : function() { },

	position : function() {
		if(this.ne.nicPanel) {
			var panelElm = this.ne.nicPanel.elm;
			var panelPos = panelElm.pos();
			var newLeft = panelPos[0]+parseInt(panelElm.getStyle('width'))-(parseInt(this.pane.getStyle('width'))+8);
			if(newLeft < this.pos[0]) {
				this.contain.setStyle({left : newLeft+'px'});
			}
		}
	},

	toggle : function() {
		this.isVisible = !this.isVisible;
		this.contain.setStyle({display : ((this.isVisible) ? 'block' : 'none')});
	},

	remove : function() {
		if(this.contain) {
			this.contain.remove();
			this.contain = null;
		}
	},

	append : function(c) {
		c.appendTo(this.pane);
	},

	setContent : function(c) {
		this.pane.setContent(c);
	}

});



var nicEditorAdvancedButton = nicEditorButton.extend({

	init : function() {
		this.ne.addEvent('selected',this.removePane.closure(this)).addEvent('blur',this.removePane.closure(this));
	},

	mouseClick : function() {
		if(!this.isDisabled) {
			if(this.pane && this.pane.pane) {
				this.removePane();
			} else {
				this.pane = new nicEditorPane(this.contain,this.ne,{width : (this.width || '270px'), backgroundColor : '#fff'},this);
				this.addPane();
				this.ne.selectedInstance.saveRng();
			}
		}
	},

	addForm : function(f,elm) {
		this.form = new bkElement('form').addEvent('submit',this.submit.closureListener(this));
		this.pane.append(this.form);
		this.inputs = {};

		for(itm in f) {
			var field = f[itm];
			var val = '';
			if(elm) {
				val = elm.getAttribute(itm);
			}
			if(!val) {
				val = field['value'] || '';
			}
			var type = f[itm].type;

			if(type == 'title') {
					new bkElement('div').setContent(field.txt).addClass("paneTitle").appendTo(this.form);
			} else {
				var contain = new bkElement('div').addClass("paneInput").appendTo(this.form);
				if(field.txt) {
					new bkElement('label').setAttributes({'for' : itm}).setContent(field.txt).appendTo(contain);
				}

				switch(type) {
					case 'text':
						this.inputs[itm] = new bkElement('input').setAttributes({id : itm, 'value' : val, 'type' : 'text'}).setStyle(field.style).appendTo(contain);
						break;
					case 'select':
						this.inputs[itm] = new bkElement('select').setAttributes({id : itm}).appendTo(contain);
						for(opt in field.options) {
							var o = new bkElement('option').setAttributes({value : opt, selected : (opt == val) ? 'selected' : ''}).setContent(field.options[opt]).appendTo(this.inputs[itm]);
						}
						break;
					case 'content':
						this.inputs[itm] = new bkElement('textarea').setAttributes({id : itm}).setStyle({border : '1px solid #ccc', 'float' : 'left'}).setStyle(field.style).appendTo(contain);
						this.inputs[itm].value = val;
				}
			}
		}
		var submit_button = new bkElement('input').setAttributes({'type' : 'submit', 'asg-button' : 'primary'}).appendTo(this.form);
		submit_button.setAttribute("asg-button", "primary");
		this.form.onsubmit = bkLib.cancelEvent;
	},

	submit : function() { },

	findElm : function(tag,attr,val) {
		var list = this.ne.selectedInstance.getElm().getElementsByTagName(tag);
		for(var i=0;i<list.length;i++) {
			if(list[i].getAttribute(attr) == val) {
				return $BK(list[i]);
			}
		}
	},

	removePane : function() {
		if(this.pane) {

			if(this.arrow_span){
				this.arrow_span.remove();
			}

			this.pane.remove();
			this.pane = null;
			this.ne.selectedInstance.restoreRng();
		}
	}
});


var nicButtonTips = bkClass.extend({
	construct : function(nicEditor) {
		this.ne = nicEditor;
		nicEditor.addEvent('buttonOver',this.show.closure(this)).addEvent('buttonOut',this.hide.closure(this));

	},

	show : function(button) {
		this.timer = setTimeout(this.create.closure(this,button),400);
	},

	create : function(button) {
		this.timer = null;
		if(!this.pane) {
			this.pane = new nicEditorPane(button.button,this.ne,{fontSize : '12px', marginTop : '5px'},false,"tooltip");
			this.pane.setContent(button.options.name);
		}
	},

	hide : function(button) {
		if(this.timer) {
			clearTimeout(this.timer);
		}
		if(this.pane) {
			this.pane = this.pane.remove();
		}
	}
});
nicEditors.registerPlugin(nicButtonTips);



 /* START CONFIG */
var nicSelectOptions = {
	buttons : {
		'fontSize' : {name : __('Select Font Size'), type : 'nicEditorFontSizeSelect', command : 'fontsize'},
		'fontFamily' : {name : __('Select Font Family'), type : 'nicEditorFontFamilySelect', command : 'fontname'},
		'fontFormat' : {name : __('Select Font Format'), type : 'nicEditorFontFormatSelect', command : 'formatBlock'}
	}
};
/* END CONFIG */
var nicEditorSelect = bkClass.extend({

	construct : function(e,buttonName,options,nicEditor) {
		this.options = options.buttons[buttonName];
		this.elm = e;
		this.ne = nicEditor;
		this.name = buttonName;
		this.selOptions = new Array();

		this.margin = new bkElement('div').setStyle({'float' : 'left', margin : '2px 1px 0 1px'}).appendTo(this.elm);
		this.contain = new bkElement('div').setStyle({width: '90px', height : '20px', cursor : 'pointer', overflow: 'hidden'}).addClass('selectContain').addEvent('click',this.toggle.closure(this)).appendTo(this.margin);
		this.items = new bkElement('div').setStyle({overflow : 'hidden', zoom : 1, border: '1px solid #ccc', paddingLeft : '3px', backgroundColor : '#fff'}).appendTo(this.contain);
		this.control = new bkElement('div').setStyle({overflow : 'hidden', 'float' : 'right', height: '18px', width : '16px'}).addClass('selectControl').setStyle(this.ne.getIcon('arrow',options)).appendTo(this.items);
		this.txt = new bkElement('div').setStyle({overflow : 'hidden', 'float' : 'left', width : '66px', height : '14px', marginTop : '1px', fontFamily : 'sans-serif', textAlign : 'center', fontSize : '12px'}).addClass('selectTxt').appendTo(this.items);

		if(!window.opera) {
			this.contain.onmousedown = this.control.onmousedown = this.txt.onmousedown = bkLib.cancelEvent;
		}

		this.margin.noSelect();

		this.ne.addEvent('selected', this.enable.closure(this)).addEvent('blur', this.disable.closure(this));

		this.disable();
		this.init();
	},

	disable : function() {
		this.isDisabled = true;
		this.close();
		this.contain.setStyle({opacity : 0.6});
	},

	enable : function(t) {
		this.isDisabled = false;
		this.close();
		this.contain.setStyle({opacity : 1});
	},

	setDisplay : function(txt) {
		this.txt.setContent(txt);
	},

	toggle : function() {
		if(!this.isDisabled) {
			(this.pane) ? this.close() : this.open();
		}
	},

	open : function() {
		this.pane = new nicEditorPane(this.items,this.ne,{width : '88px', padding: '0px', borderTop : 0, borderLeft : '1px solid #ccc', borderRight : '1px solid #ccc', borderBottom : '0px', backgroundColor : '#fff'});

		for(var i=0;i<this.selOptions.length;i++) {
			var opt = this.selOptions[i];
			var itmContain = new bkElement('div').setStyle({overflow : 'hidden', borderBottom : '1px solid #ccc', width: '88px', textAlign : 'left', overflow : 'hidden', cursor : 'pointer'});
			var itm = new bkElement('div').setStyle({padding : '0px 4px'}).setContent(opt[1]).appendTo(itmContain).noSelect();
			itm.addEvent('click',this.update.closure(this,opt[0])).addEvent('mouseover',this.over.closure(this,itm)).addEvent('mouseout',this.out.closure(this,itm)).setAttributes('id',opt[0]);
			this.pane.append(itmContain);
			if(!window.opera) {
				itm.onmousedown = bkLib.cancelEvent;
			}
		}
	},

	close : function() {
		if(this.pane) {
			this.pane = this.pane.remove();
		}
	},

	over : function(opt) {
		opt.setStyle({backgroundColor : '#ccc'});
	},

	out : function(opt) {
		opt.setStyle({backgroundColor : '#fff'});
	},


	add : function(k,v) {
		this.selOptions.push(new Array(k,v));
	},

	update : function(elm) {
		this.ne.nicCommand(this.options.command,elm);
		this.close();
	}
});

var nicEditorFontSizeSelect = nicEditorSelect.extend({
	sel : {1 : '1&nbsp;(8pt)', 2 : '2&nbsp;(10pt)', 3 : '3&nbsp;(12pt)', 4 : '4&nbsp;(14pt)', 5 : '5&nbsp;(18pt)', 6 : '6&nbsp;(24pt)'},
	init : function() {
		this.setDisplay('Font&nbsp;Size...');
		for(itm in this.sel) {
			this.add(itm,'<font size="'+itm+'">'+this.sel[itm]+'</font>');
		}
	}
});

var nicEditorFontFamilySelect = nicEditorSelect.extend({
	sel : {'arial' : 'Arial','comic sans ms' : 'Comic Sans','courier new' : 'Courier New','georgia' : 'Georgia', 'helvetica' : 'Helvetica', 'impact' : 'Impact', 'times new roman' : 'Times', 'trebuchet ms' : 'Trebuchet', 'verdana' : 'Verdana'},

	init : function() {
		this.setDisplay('Font&nbsp;Family...');
		for(itm in this.sel) {
			this.add(itm,'<font face="'+itm+'">'+this.sel[itm]+'</font>');
		}
	}
});

var nicEditorFontFormatSelect = nicEditorSelect.extend({
		sel : {'p' : 'Paragraph', 'pre' : 'Pre', 'h6' : 'Heading&nbsp;6', 'h5' : 'Heading&nbsp;5', 'h4' : 'Heading&nbsp;4', 'h3' : 'Heading&nbsp;3', 'h2' : 'Heading&nbsp;2', 'h1' : 'Heading&nbsp;1'},

	init : function() {
		this.setDisplay('Font&nbsp;Format...');
		for(itm in this.sel) {
			var tag = itm.toUpperCase();
			this.add('<'+tag+'>','<'+itm+' style="padding: 0px; margin: 0px;">'+this.sel[itm]+'</'+tag+'>');
		}
	}
});

nicEditors.registerPlugin(nicPlugin,nicSelectOptions);



/* START CONFIG */
var nicLinkOptions = {
	buttons : {
		'link' : {name : 'Add Link', type : 'nicLinkButton', tags : ['A']},
		'unlink' : {name : 'Remove Link',  command : 'unlink', noActive : true}
	}
};
/* END CONFIG */

var nicLinkButton = nicEditorAdvancedButton.extend({
	addPane : function() {
		this.ln = this.ne.selectedInstance.selElm().parentTag('A');
		this.addForm({
			'' : {type : 'title', txt : 'Add/Edit Link'},
			'href' : {type : 'text', txt : 'URL', value : 'http://', style : {width: '150px'}}
			//'title' : {type : 'text', txt : 'Title'}
		},this.ln);
	},

	submit : function(e) {
		var url = this.inputs['href'].value;
		if(url == "http://" || url == "") {
			alert("You must enter a URL to Create a Link");
			return false;
		}
		this.removePane();

		if(!this.ln) {
			var tmp = this.inputs['href'].value;
			this.ne.nicCommand("createlink",tmp);
			this.ln = this.findElm('A','href',tmp);
		}
		if(this.ln) {
			this.ln.setAttributes({
				href : this.inputs['href'].value,
				//title : this.inputs['title'].value,
				target : '_blank'
			});
		}
	}
});

nicEditors.registerPlugin(nicPlugin,nicLinkOptions);



/* START CONFIG */
var nicColorOptions = {
	buttons : {
		'forecolor' : {name : __('Change Text Color'), type : 'nicEditorColorButton', noClose : true},
		'bgcolor' : {name : __('Change Background Color'), type : 'nicEditorBgColorButton', noClose : true}
	}
};
/* END CONFIG */

var nicEditorColorButton = nicEditorAdvancedButton.extend({
	addPane : function() {
			var colorList = {0 : '00',1 : '33',2 : '66',3 :'99',4 : 'CC',5 : 'FF'};
			var colorItems = new bkElement('DIV').setStyle({width: '270px'});

			for(var r in colorList) {
				for(var b in colorList) {
					for(var g in colorList) {
						var colorCode = '#'+colorList[r]+colorList[g]+colorList[b];

						var colorSquare = new bkElement('DIV').setStyle({'cursor' : 'pointer', 'height' : '15px', 'float' : 'left'}).appendTo(colorItems);
						var colorBorder = new bkElement('DIV').setStyle({border: '2px solid '+colorCode}).appendTo(colorSquare);
						var colorInner = new bkElement('DIV').setStyle({backgroundColor : colorCode, overflow : 'hidden', width : '11px', height : '11px'}).addEvent('click',this.colorSelect.closure(this,colorCode)).addEvent('mouseover',this.on.closure(this,colorBorder)).addEvent('mouseout',this.off.closure(this,colorBorder,colorCode)).appendTo(colorBorder);

						if(!window.opera) {
							colorSquare.onmousedown = colorInner.onmousedown = bkLib.cancelEvent;
						}

					}
				}
			}
			this.pane.append(colorItems.noSelect());
	},

	colorSelect : function(c) {
		this.ne.nicCommand('foreColor',c);
		this.removePane();
	},

	on : function(colorBorder) {
		colorBorder.setStyle({border : '2px solid #000'});
	},

	off : function(colorBorder,colorCode) {
		colorBorder.setStyle({border : '2px solid '+colorCode});
	}
});

var nicEditorBgColorButton = nicEditorColorButton.extend({
	colorSelect : function(c) {
		this.ne.nicCommand('hiliteColor',c);
		this.removePane();
	}
});

nicEditors.registerPlugin(nicPlugin,nicColorOptions);



/* START CONFIG */
var nicImageOptions = {
	buttons : {
		'image' : {name : 'Add Image', type : 'nicImageButton', tags : ['IMG']}
	}

};
/* END CONFIG */

var nicImageButton = nicEditorAdvancedButton.extend({
	addPane : function() {
		this.im = this.ne.selectedInstance.selElm().parentTag('IMG');
		this.addForm({
			'' : {type : 'title', txt : 'Add/Edit Image'},
			'src' : {type : 'text', txt : 'URL', 'value' : 'http://', style : {width: '150px'}},
			'alt' : {type : 'text', txt : 'Alt Text', style : {width: '100px'}},
			'align' : {type : 'select', txt : 'Align', options : {none : 'Default','left' : 'Left', 'right' : 'Right'}}
		},this.im);
	},

	submit : function(e) {
		var src = this.inputs['src'].value;
		if(src == "" || src == "http://") {
			alert("You must enter a Image URL to insert");
			return false;
		}
		this.removePane();

		if(!this.im) {
			var tmp = 'javascript:nicImTemp();';
			this.ne.nicCommand("insertImage",tmp);
			this.im = this.findElm('IMG','src',tmp);
		}
		if(this.im) {
			this.im.setAttributes({
				src : this.inputs['src'].value,
				alt : this.inputs['alt'].value,
				align : this.inputs['align'].value
			});
		}
	}
});

nicEditors.registerPlugin(nicPlugin,nicImageOptions);

/* START CONFIG */
var nicSaveOptions = {
	buttons : {
		'save' : {name : __('Save this content'), type : 'nicEditorSaveButton'}
	}
};
/* END CONFIG */

var nicEditorSaveButton = nicEditorButton.extend({
	init : function() {
		if(!this.ne.options.onSave) {
			this.margin.setStyle({'display' : 'none'});
		}
	},
	mouseClick : function() {
		var onSave = this.ne.options.onSave;
		var selectedInstance = this.ne.selectedInstance;
		onSave(selectedInstance.getContent(), selectedInstance.elm.id, selectedInstance);
	}
});

nicEditors.registerPlugin(nicPlugin,nicSaveOptions);

/* START CONFIG */
var nicYouTubeOptions = {
  buttons : {
    'youtube': {name : 'Add Video', type : 'nicYouTubeButton'}
  }
};
/* END CONFIG */

var nicYouTubeButton = nicEditorButton.extend({
	width: '350px',

	mouseClick: function () {
		if(!this.isDisabled){
			this.vi_field = this.ne.selectedInstance.selElm();
			$.facebox({
				div: '#video_popup'
			}, "nicedit_video");
			nicedit_video.init(this);
			$('body').addClass("facebox_open");
		}
	}
});

var nicedit_video = (function($){

	var elements = {

		acquire:function(instance){
			this.video_popup 		= $('#facebox.nicedit_video #video_popup');
			this.close_icon			= $('#facebox.nicedit_video .footer i.icon-remove');
			this.save_button 		= this.video_popup.find('.fgroup button.save');
			this.cancel_button 		= this.video_popup.find('.fgroup button.cancel');
			this.search_button 		= this.video_popup.find('fieldset.search_form button.search');
			this.search_keyword 	= this.video_popup.find('fieldset.search_form input.yt_search');
			this.results_list		= this.video_popup.find('ul.yt_search_results');
			this.instance			= instance;
			this.selected_instance	= instance.ne.selectedInstance;
			this.fetching 			= false;
			this.nextPageToken 		= "";
			this.editor_options		= instance.ne.selectedInstance.ne.options;
		},

		reacquire:function(){
			this.video_result 		= this.video_popup.find('li.video_frame');
		}

	};

	var ev = {

		bind:function(){
			elements.search_button.on('click', ev.search_click);
			elements.search_keyword.on('keyup', ev.search_keyup);
			elements.save_button.on('click', ev.insert_video);
			elements.cancel_button.on('click', function(){
				$.facebox.close();
			});
			$(document).on('close.facebox', ev.reset_modal);

		},

		rebind:function(){
			elements.video_result.on('click', ev.select_video);
			elements.results_list.on("scroll", ev.infinite_scroll);
		},

		infinite_scroll : function(e){
			if($(this).prop('scrollHeight') - $(this).scrollTop() < 600 && !elements.fetching){
				elements.fetching = true;
				elements.search_button.trigger('click');
			}
		},

		select_video : function (){
			if(!$(this).hasClass('selected')){
				elements.video_result.each(function( index ){
					$(this).removeClass('selected');
					$(this).find('button.use_video').removeClass('selected');
				})
				$(this).addClass('selected');
				$(this).find('button.use_video').addClass('selected');
				elements.save_button.prop('disabled',false);
			}
		},

		reset_modal : function(){
			$('body').removeClass("facebox_open");
			elements.results_list.html("");
		},

		insert_video : function(){
			var video_id = 0;
			elements.video_result.each(function( index ){
				if($(this).hasClass('selected')){
					video_id = $(this).data('videoid');
				}
			});

			if(video_id){

				if(elements.editor_options.placeholder == elements.selected_instance.getContent()){
					elements.selected_instance.setContent("");
				}

				if(!$(elements.instance.vi_field).is(":last-child")){
					iframe_node = document.createElement("iframe");
					iframe_node.setAttribute("src", "https://www.youtube.com/embed/" + video_id);
					iframe_node.style.width = "100%";
					iframe_node.style.height = "315px";
					$(elements.instance.vi_field).next().prepend(iframe_node);
				}
				else{
					youTubeCode = '<iframe width="100%" height="315" src="https://www.youtube.com/embed/' + video_id + '" frameborder="0" allowfullscreen></iframe>';
					elements.selected_instance.setContent(elements.selected_instance.getContent() + youTubeCode);
				}
			}
			else{
			 	alert("There was a problem embedding video");
			}
			$.facebox.close();
		},

		search_keyup : function(e){
			elements.nextPageToken = "";
			if($(this).val().length == 0){
				elements.search_button.prop('disabled',true);
			}
			else{
				elements.search_button.prop('disabled',false);
				if((e.keyCode == 13)){
					e.preventDefault();
					elements.search_button.trigger('click');
				}
			}
		},

		search_click : function(){

			if(elements.search_keyword.val().length == 0 && !elements.editor_options.defaultVideoSearch){
				return false;
			}
			else if(elements.search_keyword.val().length > 0){
				ev.search(elements.search_keyword.val());
			}
			else{
				ev.search(elements.editor_options.defaultVideoSearch);
			}

		},

		search : function(keyword){

			url = "https://www.googleapis.com/youtube/v3/search?videoEmbeddable=true&type=video&maxResults=10&part=snippet&key=AIzaSyDDhwvyIQuvzWSqm-CvW1EWvzRog27HdgY&q=" + encodeURIComponent(keyword);
			//url = "https://www.googleapis.com/youtube/v3/search?videoEmbeddable=true&type=video&maxResults=10&part=snippet&key=AIzaSyCRZ_rHkfAU0GL9BNN1JfCDKaJSu_TuMKM&q=" + encodeURIComponent(keyword);
			if(elements.nextPageToken.length > 0){
				url += "&pageToken=" + elements.nextPageToken
			}
			$.ajax({
				url: url,
				type:'GET',
				dataType : 'jsonp',
				success:function(response)
				{
					var ids = [];
					$.each(response.items, function (index, data) {
						ids[ids.length] = data.id.videoId;
				    });

					url = "https://www.googleapis.com/youtube/v3/videos?id=" + ids.join() + "&part=contentDetails,statistics&key=AIzaSyDDhwvyIQuvzWSqm-CvW1EWvzRog27HdgY"
				    //url = "https://www.googleapis.com/youtube/v3/videos?id=" + ids.join() + "&part=contentDetails,statistics&key=AIzaSyCRZ_rHkfAU0GL9BNN1JfCDKaJSu_TuMKM"
					$.ajax({
						url: url,
						type:'GET',
						dataType : 'jsonp',
						success:function(details_response)
						{
							var markup = "",
								m_names = new Array("Jan", "Feb", "Mar",
								"Apr", "May", "Jun", "Jul", "Aug", "Sep",
								"Oct", "Nov", "Dec");

							$.each(response.items, function (index, data) {
								var duration = "";
									views = "";

								$.each(details_response.items, function (d_index, d_data) {
									if(d_data.id == data.id.videoId){
										duration_array = d_data.contentDetails.duration.match(/(\d+)(?=[MHS])/ig)||[];
										duration = duration_array.map(function(item){
										    if(item.length<2) return '0'+item;
										    return item;
										}).join(':');
										views = d_data.statistics.viewCount.toString().replace(/,/g, "").replace(/\B(?=(\d{3})+(?!\d))/g, ",");
										return false;
									}
								});

								var d = new Date(data.snippet.publishedAt);
								date = m_names[d.getMonth()] + " " + d.getDate() + ", " + d.getFullYear();
						        markup += "<li class='video_frame' asg-card data-videoid='" + data.id.videoId + "'><div class='yt_video'><iframe width='420' height='236' src='http://www.youtube.com/embed/" + data.id.videoId + "'></iframe></div><div class='yt_info'><div class='yt_title'>" + data.snippet.title + "</div><div class='yt_views'>" + views + " views</div><div class='yt_duration'>" + duration + " - Published on " + date + "</div><div class='yt_desc'>" + data.snippet.description + "</div><button class='use_video' asg-button='secondary toggle'>Use this video</button></div></li>";
						    });
							elements.results_list.find('.yt_loading').hide();
							markup += '<div asg-loading class="yt_loading"></div>';

							if(elements.nextPageToken.length > 0){
								elements.results_list.append(markup);
							}
							else{
								elements.results_list.animate({ scrollTop: 0 });
								elements.results_list.html(markup);
							}

							elements.save_button.prop('disabled',true);
							elements.nextPageToken = response.nextPageToken;
							elements.fetching = false;
							elements.reacquire();
							ev.rebind();
						}
					});
				}
			});
		}
	};

	return {
		init:function(instance){
			elements.acquire(instance);
			ev.bind();

			if(elements.editor_options.defaultVideoSearch){
				ev.search(elements.editor_options.defaultVideoSearch);
			}
		}
	};
})(jQuery);


nicEditors.registerPlugin(nicPlugin,nicYouTubeOptions);


/*!
 * hoverIntent v1.8.0 // 2014.06.29 // jQuery v1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */
(function($){$.fn.hoverIntent=function(handlerIn,handlerOut,selector){var cfg={interval:100,sensitivity:6,timeout:0};if(typeof handlerIn==="object"){cfg=$.extend(cfg,handlerIn)}else{if($.isFunction(handlerOut)){cfg=$.extend(cfg,{over:handlerIn,out:handlerOut,selector:selector})}else{cfg=$.extend(cfg,{over:handlerIn,out:handlerIn,selector:handlerOut})}}var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if(Math.sqrt((pX-cX)*(pX-cX)+(pY-cY)*(pY-cY))<cfg.sensitivity){$(ob).off("mousemove.hoverIntent",track);ob.hoverIntent_s=true;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=false;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=$.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type==="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).on("mousemove.hoverIntent",track);if(!ob.hoverIntent_s){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).off("mousemove.hoverIntent",track);if(ob.hoverIntent_s){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.on({"mouseenter.hoverIntent":handleHover,"mouseleave.hoverIntent":handleHover},cfg.selector)}})(jQuery);

$('.question_card_answer').each(function(){
	var $this = $(this);

	var eles = {
		content									: $this.find('div.content'),
		improve_answer_container 				: $this.find('.improve_answer_container'),
		improve_answer_button					: $this.find('.improve_answer_button'),
		answer_text 							: $this.find('.answer_text'),
		improve_answer_container_error_message 	: $this.find('.improve_answer_container .error_message'),
		params 									: $(this).data('jsparams'),
		expert_response							: $this.find('.expert_response'),
		super_options							: $this.find('.show_options .options'),
		standard_message						: $this.find('.nicEdit').attr('placeholder'),
		original_edit_text 						: '',
		ynp                                     : $this.find('.ynp'),
		ynp_thanks                              : $this.find('.ynp_thanks'),
		answer_wrapper                          : $this.find('.answer_wrapper'),
		flagged_for_improvement_button          : $this.find('.flagged_for_improvement button'),
		flagged_for_improvement_button_span     : $this.find('.flagged_for_improvement button span')
	};

	var functions = {

		ynp_submit: function(value) {
			var vote_value;
			if(value=="Yes"){
				vote_value = 1;
			}
			else if(value=="No"){
				vote_value = 3;
			}
			else{
				vote_value = 2;
			}
			$.ajax({
				url: "/solo/feedback",
				type:'POST',
				data:{
					'do':'vote',
					'depth': 0,
					'value': vote_value,
					'position': 0,
					'page': eles.params.page,
					'mode_id': eles.params.mode,
					'question_id': eles.params.qid,
					'question_title': eles.params.qtitle,
					'initial_event_type': "yesnopartial"
				},
				success:function()
				{
					eles.ynp.hide();
					eles.ynp_thanks.removeClass('hide');
				}
			});
		},

		show_edit_box: function()
		{
			eles.improve_answer_container.show();
			eles.improve_answer_button.hide();
			eles.answer_text.hide();
			eles.original_edit_text = eles.improve_answer_container.find('.nicEdit-main').html();
		},

		hide_edit_box: function()
		{
			eles.improve_answer_container.hide();
			eles.improve_answer_button.show();
			eles.answer_text.show();
		},

		reset_edit_box: function()
		{
			eles.improve_answer_container.find('.nicEdit-main').html(eles.original_edit_text);
		},

		improve_answer_clicked: function()
		{
			var editor_text = $this.find('.nicEdit-main').text();
			if(eles.params.is_answered)
			{
				functions.save_answer();
			}
			else
			{
				var text_value = eles.super_options.val();
				var name = '';
				if(text_value == 'ask_for_more_detail') {
					functions.save_option('marked_as_vague');
					gatracking.fire(['_trackEvent','unanswered_q_response',text_value]);
				}
				else if(text_value == 'requires_expert_response') {
					functions.save_option('marked_as_challenging');
					gatracking.fire(['_trackEvent','unanswered_q_response',text_value]);
				}
				else {
					functions.save_answer();
				}
			}
		},

		expand_collapse: function()
		{
			if(eles.content.hasClass('collapsed'))
			{
				functions.expand();
			}
			else
			{
				functions.collapse();
			}
		},
		expand: function()
		{
			eles.flagged_for_improvement_button_span.html('Hide');
			var divs = $this.find('.collapsed');
			divs.addClass('expanded');
			divs.removeClass('collapsed');
			eles.answer_wrapper.removeClass('hide');
		},
		collapse: function()
		{
			eles.flagged_for_improvement_button_span.html('Show');
			var divs = $this.find('.expanded');
			divs.addClass('collapsed');
			divs.removeClass('expanded');
			eles.answer_wrapper.addClass('hide');
		},

		save_option: function(meta_type, callback)
		{
			if (!callback) {
				callback = function(response)
				{
					window.location.href = eles.params.qurl;
				};
			}
			if(meta_type == 'marked_as_challenging')
			{
                gatracking.fire(['_trackEvent','unanswered_q_response','requires_expert_response']);
                $.ajax({
					url      : "/solo/ajax/question/answer/challenging",
					type     : 'POST',
					dataType : 'json',
					async	 : 'false',
					data     : {
						'question'              : $this.find('fieldset.improve_answer_container input[name=question_title]').val()
					},
					success:callback,
					error : function(response)
					{
						window.location.href = eles.params.qurl;
					}
				});
			}
			else if(meta_type == 'marked_as_vague')
			{
				var text = $this.find('.improve_answer_container .nicEdit-main').html();
				if (text == $this.find('.nicEdit').val()) {
					text = "";
				}
                gatracking.fire(['_trackEvent','unanswered_q_response','ask_for_more_detail']);
                // ajax call to solo/ajax/question/answer/vague
				$.ajax({
					url      : "/solo/ajax/question/answer/vague",
					type     : 'POST',
					dataType : 'json',
					async	 : 'false',
					data     : {
						'answer'                : text,
						'etag'                  : $this.find('fieldset.improve_answer_container input[name=question_etag]').val(),
						'question'              : $this.find('fieldset.improve_answer_container input[name=question_title]').val()
					},
					success : function(response)
					{
						window.location.href = eles.params.qurl;
					},
					error : function(response)
					{
						window.location.href = eles.params.qurl;
					}
				});
			}
		},

		save_answer: function()
		{
			eles.improve_answer_container_error_message.html('');
			var text = eles.improve_answer_container.find('.nicEdit-main').html();
			text = (text == eles.standard_message) ? '' : text.trim();

			data = {
				'answer'                : text,
				'question'              : $this.find('fieldset.improve_answer_container input[name=question_title]').val(),
				'etag'                  : $this.find('fieldset.improve_answer_container input[name=question_etag]').val(),
				'confirmedDeleteAnswer' : false,
				'watchThis'             : false
			};
			if(eles.params.is_answered)
			{
				data['minorEdit'] 		= $this.find('fieldset.improve_answer_container input[name=minor_edit]').prop('checked');
				data['first_answer'] 	= false;
			}
			else
			{
				data['minorEdit'] 		= false;
				data['first_answer']	= true;

				gatracking.fire(['_trackEvent','unanswered_q_response','answered']);
			}


			$.ajax({
				url      : "/solo/ajax/question/answer",
				type     :'POST',
				dataType : 'json',
				data     : data,
				success:function(response)
				{
					if(response.type == 'error')
					{
						eles.improve_answer_container_error_message.html(response.error_message);

						if (response.new_answer)
						{
							$this.find('.improve_answer_container .nicEdit-main').html(response.new_answer);
						}

					}
					else if(response.type == 'success')
					{
						if(eles.params.is_answered)
						{
							functions.hide_edit_box();
							eles.answer_text.html(text);
							eles.improve_answer_container.find('.nicEdit').html(text);
							if (response.etag)
							{
								$this.find('fieldset.improve_answer_container input[name=question_etag]').val(response.etag);
							}

							$(document).trigger({ type: 'update_flags', flag_type: 'answer' });
						}
						else
						{
							window.location.href = eles.params.qurl;
						}
					}
					else
					{
						eles.improve_answer_container_error_message.html('There was a problem trying to save your answer.');
					}
				}
			});
		},

		super_options_changed: function()
		{
			var text_value = eles.super_options.val();
			var card = $this;

			eles.expert_response.hide();

			card.removeClass('ask_for_more_detail requires_expert_response');
			switch (text_value) {
				case 'answer_it':
					text = eles.standard_message;
					card.find('.nicEdit-main').html(text);
					break;
				case 'ask_for_more_detail':
					card.addClass('ask_for_more_detail');
					text = 'The Answers community requested more information for this question. Please edit your question to include more context.';
					card.find('.nicEdit-main').html(text);
					break;
				case 'requires_expert_response':
					eles.expert_response.show();
					card.addClass('requires_expert_response');
					break;
			}
		}
	};

	if(eles.params.delay_textarea_fill === true){
		eles.improve_answer_container.find('.nicEdit').html(eles.answer_text.html());
		eles.improve_answer_container.find('.nicEdit-main').html(eles.answer_text.html());
	}

	eles.expert_response.hide();
	eles.super_options.on('change', functions.super_options_changed);

	eles.improve_answer_button.on(
		'click',
		function()
		{
			if(eles.content.hasClass('collapsed'))
			{
				functions.expand();
			}
			functions.show_edit_box();
		}
	);

	eles.improve_answer_container.on(
		'click',
		'button.cancel',
		function()
		{
			functions.hide_edit_box();
			functions.reset_edit_box();
		}
	);

	eles.improve_answer_container.on(
		'click',
		'button.save',
		function()
		{
			functions.improve_answer_clicked();
		}
	);

	eles.ynp.show();
	eles.ynp.on(
		'click',
		'button',
		function(event)
		{
			functions.ynp_submit($(this).html());
		}
	);

	eles.flagged_for_improvement_button.on('click', functions.expand_collapse);

	$this.on('focus click mousedown', '.nicEdit-main', function() {
		if ($(this).text().trim() == eles.standard_message) {
			$(this).html("");
			$(this).attr('tabindex', '0').focus();
		}
	});

	$this.on('blur', '.nicEdit-main', function() {
		if ($(this).text().trim() == "") {
			$(this).text(eles.standard_message);
		}
	});

	$(document).ready(function(){
		if(!eles.params.is_answered)
		{
			functions.show_edit_box(); //give time for nicedit to initialize
			functions.super_options_changed();
			$(this).find('.question_card_answer .nicEdit-main').text(eles.standard_message);
		}
		if(eles.params.expand_edit) {
			functions.show_edit_box();
		}
	})

});


(function(d, s, id) {
	var js, fjs = d.getElementsByTagName(s)[0],appID = parseInt(fb_app_id, 10);
	if (d.getElementById(id)) return;
	js = d.createElement(s); js.id = id;
	js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&appId=" + appID + "&version=" + fb_graph_version;
	fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

var fb_check_interval;
$(document).ready( function() {
	fb_check_interval = setInterval(function(){
		if(typeof(_gaq)!=='undefined'){
			if(typeof(FB)!=='undefined'){
				clearInterval(fb_check_interval);

				FB.Event.subscribe('edge.create', function(url) {
					$(document).trigger('social_on_page', {eventThrown: event, eventType: 'like', moduleName: 'social_facebook_like'});
					_gaq.push(['_trackEvent', 'module', 'social/facebook/like', 'liked_fb']);
				});

				FB.Event.subscribe('edge.remove', function() {
					$(document).trigger('social_on_page', {eventThrown: event, eventType: 'unlike',moduleName: 'social_facebook_like'});
					_gaq.push(['_trackEvent', 'module', 'social/facebook/like', 'unliked_fb']);
				});
			}
		}
	}, 100);
});

(function() {

	var injectButtons = function() {
		var i = 0;

		while (__page_data__['social_facebook_like-' + i]) {
			var params = __page_data__['social_facebook_like-' + i].fb_params;

			var url = window.location.origin+ window.location.pathname;
			var fbLike = document.createElement('div');

			fbLike.setAttribute('data-href', url);
			fbLike.setAttribute('class','fb-like');
			fbLike.setAttribute('data-layout', params.layout);
			fbLike.setAttribute('data-action', 'like');
			fbLike.setAttribute('data-show-faces', params.show_faces);
			fbLike.setAttribute('data-share', params.share);
			fbLike.setAttribute('data-width', params.width);
			fbLike.setAttribute('data-colorscheme', params.colorscheme);
			fbLike.setAttribute('data-type', params.type);

			$('.' + params.module_class).html(fbLike);

			i++;
		}
	};

	var refreshButtons = function() {
		FB.XFBML.parse();
	};

	injectButtons();

	if (!!__page_data__['social_facebook_like-0']) {
		$(document).on('desktop_slide.nextarticle desktop_slide.prevarticle', function() {
			injectButtons();
			refreshButtons();
		});
	}

}());


var links_casale = (function() {
	'use strict';

	var defintion = function() {

		this.attributes({
			infinite_scroll_pane_location: undefined
		});

		this.after('initialize', function() {
			if (this.attr.infinite_scroll_pane_location && carousel_mixin_infinitescroll) {
				carousel_mixin_infinitescroll.register_module({
					infinite_scroll_pane_location: this.attr.infinite_scroll_pane_location,
					height: this.attr.height || '',
					node: this.$node
				});
			}
		});
	};

	try {
		return flight.component(defintion);
	} catch(e) {
		// flight undefined
	}
})();


(function($){
	var followingtile_js = function(following_tile, card_type) {

		var $this = $(following_tile),
				$feedcard = $(following_tile).closest(card_type);

		$feedcard.addClass('followingtile_jscomplete');
		var vars = $feedcard.data('jsparams');

		vars['cardparams'] = $feedcard.data('cardparams');
		
		var elements = {
			following_tile	: $feedcard.find('.following_tile'),
			selected		: ''
		};

		var functions= {
			follow: function(item) {
				var followid = $(item).data('followid');
				var followtype = $(item).data('followtype');
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: followid,
						type: followtype
					}
				});
			},
			unfollow: function(item) {
				var followid = $(item).data('followid');
				var followtype = $(item).data('followtype');
				var removing_expert_follow = 'yes';
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_expert_follow,
						ids: followid,
						type: followtype
					}
				});
			}
		};

		var tile_click = function(item) {

			var following_button = item.find('.action_text');
			if(following_button.hasClass('selected')){
				following_button.removeClass('selected');
				following_button.html('Follow');
			 	functions.unfollow(item);
			}
			else {
			 	following_button.addClass('selected');
			 	following_button.html('Following <i class="fa fa-check"></i>');
			 	functions.follow(item);
			}

		};

		//EVENTS
		elements.following_tile.on('click', function(event) {

			if(vars.user_id == null) {
				elements.selected = $(this);
				$(document).trigger("login_required");
			}
			else {
				elements.selected = '';
				tile_click($(this));
			}
		});

		$feedcard.on('click', function(event) {

			if(!$(event.target).is("img") && !$(event.target).is("span"))
			{
				var url = $feedcard.find('.frame').data('interviewurl');
				window.location = url;
			}

		});

		$(document).off('login_successful').on('login_successful', function(){

			if(elements.selected !== '') {

			 	tile_click(elements.selected);
			 	elements.selected = '';

			 		//delay refresh momentarily to allow follow to be saved
			 	setTimeout(function() {
					 location.reload();
					}, 500);
			}
		});

		$(document).on( 'login_failure', function() {
			elements.selected = '';
		});

	}

	$('.feedcard:not(.followingtile_jscomplete) .following_tile').each(function() {
		followingtile_js(this, '.feedcard');
	});

	$(document).on('js_infinite_new_content', function() {
    	$('.feedcard:not(.followingtile_jscomplete) .following_tile').each(function() {
			followingtile_js(this, '.feedcard');
		});
	});
})(jQuery);

(function($){

  var feedcard_js = function(){
    var $this = $(this);
    if($this.parent().hasClass('feedcards_wikilite_usercategories_unanswered') && typeof $this.parent().data('offset_wikilite_usercats_unanswered') == 'undefined') {
      $this.parent().attr('data-offset_wikilite_usercats_unanswered', 0);
    }
    $this.addClass('jscomplete');
    var vars = $this.data('jsparams');

    vars['cardparams'] = $this.data('cardparams');

    var elements = {
      answer_text           : $this.find("p.answer_text"),
      question_text         : $this.find("a.title_link"),
      share_facebook_button : $this.find("button[asg-social='facebook']"),
      share_twitter_button  : $this.find("button[asg-social='twitter']"),
      share_google_plus     : $this.find("button[asg-social='googleplus']"),
      reveal_share_button   : $this.find("button.share"),
      login_to_ask_button   : $this.find("button.login_to_ask_button"),
      share_container       : $this.find(".share_container"),
      share_wrapper         : $this.find(".share_wrapper"),
      answer_button         : $this.find("button.answer"),
      answer_text_field     : $this.find("input.uq_answer"),
      error_message         : $this.find("div.error"),
      submit                : $this.find('.ask'),
      submit_form           : $this.find('.search_input'),
      frame                 : $this.find(".frame"),
      question_edit         : $this.find("a.pencil_mark"),
      close_edit_question   : $this.find("a.close_edit_question"),
      edit_question_box     : $this.find("div.edit_question"),
      edit_question_button  : $this.find("button.edit_question_submit"),
      merge_question_box    : $this.find("div.merge_question"),
      close_merge_question  : $this.find("a.close_merge_question"),
      new_q_merge           : $this.find("a.new_question"),
      old_q_merge           : $this.find("a.old_question"),
      merge_question_button : $this.find("button.merge_question_submit"),
      card_overlay          : $this.find("div.card_overlay"),
      question_textarea     : $this.find("textarea.new_title_text"),
      current_user_avatar   : $this.find(".avatar_container.current img"),
      edit_image_button     : $this.find('.edit_image'),
      q_image               : $this.find('img.q_image')
    };

    var events = {
      share_facebook_clicked : function(evt){
        var url = $(this).data('url');
        window.open(url,'_newtab');
        return false;
      },
      share_twitter_clicked : function(evt){
        var url = $(this).data('url');
        window.open(url,'_newtab');
        return false;
      },
      share_google_plus_clicked : function(evt){
        var url = $(this).data('url');
        window.open(url,'_newtab');
        return false;
      },
      reveal_share_clicked: function(evt) {
        elements.share_container.toggleClass('hide');
        elements.share_wrapper.bind('mouseleave', events.hide_share_container);
        return false;
      },
      hide_share_container: function(evt) {
        elements.share_container.addClass('hide');
        elements.share_wrapper.unbind('mouseleave');
        return false;
      },
      trigger_login: function(evt) {
        $(document).trigger('login_required', 'login');
      },
      show_edit_question: function() {
        elements.card_overlay.show();
        elements.edit_question_box.show();
        elements.edit_question_box.find('.new_title_text').autosize({append:"\n"});
        elements.close_edit_question.show();
        elements.edit_question_button.show();
        elements.question_edit.hide();
        elements.question_text.hide();
      },
      close_edit_question: function() {
        elements.card_overlay.hide();
        elements.edit_question_box.find('.new_title_text').val(elements.question_text.text());
        elements.edit_question_box.find('.new_title_text').autosize({append:"\n"});
        events.change_save_button();
        elements.edit_question_box.hide();
        elements.question_edit.show();
        elements.question_text.show();
        elements.error_message.addClass('hide');
      },
      submit_question_edit: function(new_text) {
        if (!vars.user_id || vars.user_id.length === 0) {
          events.trigger_login();
        }
        else if ($.trim(new_text).length === 0) {
          show_error_message('Sorry this question cannot be deleted.');
          events.close_edit_question();
          return false;
        }
        else if (vars.cardparams.content_title == new_text) {
          show_error_message('Please change the question text.');
          return false;
        }

        var etag = vars.cardparams.content_etag,
            rename_url = vars.cardparams.question_rename_link + encodeURIComponent(new_text);

        $.ajax({
          url: rename_url,
          type: 'POST',
          success: function(respdata) {
            if(respdata.status == "success") {
              events.set_question_attributes(new_text);
              events.close_edit_question();
            }
            else {
              if( respdata.error_code == 409013 ) {
                elements.close_edit_question.hide();
                elements.edit_question_button.hide();
                events.show_merge(respdata);
              }
              else if (typeof respdata.message != 'undefined') {
                show_error_message(respdata.message);
              }
              else {
                show_error_message("Sorry, this question cannot be renamed.");
              }
            }
          },
          error: function(data){
            if(typeof data.message != "undefined") {
              show_error_message(data.message);
            }
            else {
              show_error_message("Sorry, this question cannot be renamed.");
            }
          },
          dataType: 'json'
        });

      },
      show_merge: function(respdata) {
        // respdata.conflict_title.additional[0].attributes.href;
        var q_url = vars.cardparams.content_url;
        q_url = q_url.replace(q_url.substr(q_url.lastIndexOf('/') + 1), '');
        // New q already exists, the question into which the old q is being merged into..

        elements.new_q_merge.text(respdata.new_q_text);
        elements.old_q_merge.text(respdata.old_q_text);
        elements.new_q_merge.attr("href", q_url + respdata.new_q_href);
        elements.old_q_merge.attr("href", q_url + respdata.old_q_href);
        elements.merge_question_box.show();
      },
      submit_merge_question: function() {
        var new_text  = elements.new_q_merge.text();
        var merge_url = vars.cardparams.question_merge_link + encodeURIComponent(new_text);
        $.ajax({
          url: merge_url,
          type: 'POST',
          success: function(respdata) {
            if(respdata.status == "success") {
              events.set_question_attributes(new_text);
              events.close_merge_question();
            }
            else {
              show_error_message("Sorry, there was an error in merging the question.");
              events.close_merge_question();
            }
          },
          error: function(data){
            show_error_message(data.message);
            events.close_merge_question();
          },
          dataType: 'json'
        });
      },
      close_merge_question: function() {
        elements.merge_question_box.hide();
        events.close_edit_question();
      },
     change_save_button: function(){
        var new_text = elements.frame.find('.new_title_text').val().replace(/(\?|\ )+$/gi, "");
        var old_text = elements.question_text.text().replace(/(\?|\ )+$/gi, "");
        if( old_text == new_text ) {
          elements.edit_question_button.attr('asg-button','disabled');
        }
        else {
          elements.edit_question_button.attr('asg-button', "");
        }
      },
      set_question_attributes: function(new_text) {
        elements.question_text.text(new_text);
        var new_href = new_text.replace(/\ /g, "_");
        var old_href = vars.cardparams.content_title.replace(/\ /g, "_");
        var re = new RegExp(old_href,"g");
        var new_link = vars.cardparams.content_url.replace(re, new_href);
        vars.cardparams.content_url = new_link;
        vars.cardparams.content_title = new_text;
        elements.question_text.attr("href", new_link);
      },
      submit_brand_question: function() {

        var url   = vars.submit_link;
        var question = elements.submit_form.val();

        if ($.trim(question).length === 0) {
          show_error_message('Sorry! Your question cannot be empty.');
          return false;
        }

        if (!vars.user_id || vars.user_id.length === 0) {
          events.trigger_login();
        }

        var data  = {
          'brand_id'  : vars['cardparams'].avatar_id,
          'user_id'   : vars.user_id,
          'brand'     : vars['cardparams'].avatar_name,
          'question'  : question,
          'ajax'      : 1
        };

        $.ajax({
          url: url,
          type: 'POST',
          data: data,
          success: function(respdata) {
            show_error_message(respdata.message);
            elements.submit_form.val('');
          },
          error: function(data){
            show_error_message(data.message);
            elements.submit_form.val('');
          },
          dataType: 'json'
        });
      },
      launch_image_picker: function(){
        var url = vars.image_editor_url;
        url = url + '?cur_id=' + vars.cardparams.content_id
                  + '&category_names=' + encodeURIComponent(vars.cardparams.category_title);

        if($this.closest('.module').hasClass('feedcards_friendgraph')) {
          url += '&type=friendgraph';
        }

        $(document).on('loading.facebox', function(){
          $('#facebox .loading').css('position', 'fixed');
          $('#facebox .loading').css('border-radius', '3px');
          $('#facebox .loading').css('background-color', 'white');
          $('#facebox .loading').css("top", ( $(window).height() - $('#facebox .loading').height() ) / 2+$(window).scrollTop() + "px");
          $('#facebox .loading').css("left", ( $(window).width() - $('#facebox .loading').width() ) / 2+$(window).scrollLeft() + "px");
        });

        $(document).on('beforeReveal.facebox', function(){
          $('#facebox').hide();
          setTimeout(function(){$('#facebox').show();}, 1500);
        })
        $(document).on('reveal.facebox', function(){
          setTimeout(function(){$('#facebox').css('left', $(window).width() / 2 - ($('#facebox table').width() / 2));}, 1500); 
        })
        $.facebox({ajax: url});
        $('body').addClass('facebox_open');
      }
    };

    var check_cutoff = function(i){
      if($(i).hasClass("truncated_text"))
      {
        $(i).closest('.feedcard').addClass("long_answer");
      }
    };

    var show_error_message = function(msg){
      elements.error_message.html(msg);
      elements.error_message.removeClass('hide');
      elements.error_message.removeClass("success");
      elements.frame.addClass('contains_error');
    };

    var show_success_message = function(msg){
      elements.frame.removeClass("contains_error");
      elements.frame.addClass("success");
      elements.error_message.removeClass('hide');
      elements.error_message.html(msg);
    };


    // the friends graph feed paginates differently than the other feedcards
    // so we need to append/replace the max_ts param on the nextlink href
    // so we don't have dupes in the feed
    var append_max_ts = function(max_ts){
      $('.feedcards_scroll a.nextlink').each(function(){
        var href = $(this).attr("href");
        $(this).attr("href",replace_max_ts(href,max_ts));
      });
    };

    // alters a url and replaces the "max_ts" param in the query string
    var replace_max_ts = function(href,max_ts){
      var a = href.split("?");
      var b = "max_ts=" + escape(max_ts);
      if(typeof a[1]!=='undefined'){
        var c = a[1].split("&");
        for(i=0;i<c.length;i++){
          var d = c[i].split("=");
          if(typeof d[0] !== "undefined" && d[0] != "max_ts"){
            b += "&" + c[i];
          }
        }
      }
      return a[0] + "?" + b;
    };

    var load_new_profile_picture = function(ev, data){
      elements.current_user_avatar.attr('src', data);
    };
    var extract_filename_from_url = function(url){
      //getting string after upload
      var upload = url.indexOf('upload/');
      var cloud_string = url.substring(upload+7);
      var file_name_ix = cloud_string.indexOf('/') + 1;
      return cloud_string.substring( file_name_ix );
    };
    $(document).on("ready", check_cutoff(elements.answer_text));
    $(document).on('new_profile_picture', load_new_profile_picture);
    $(document).on('change_question_image', function(e){
      if( vars.cardparams.content_id == e.cur_id ) {
        var file_name = extract_filename_from_url( e.cur_image );
        var url = elements.q_image.attr('src');
        var upload_i = url.indexOf('upload/');
        var cloud_string = url.substring( upload_i + 7 );
        var image_params = cloud_string.substring(0, cloud_string.indexOf('/'));
        image_params = (image_params.length > 0) ? image_params : vars.category_image_param_string;
        var new_src   = '//file.answcdn.com/answ-cld/image/upload/'+ image_params + '/' + file_name;
        elements.q_image.attr('src', new_src);
      }
    });
    //attach events
    elements.share_facebook_button.on('click', events.share_facebook_clicked);
    elements.share_twitter_button.on('click', events.share_twitter_clicked);
    elements.share_google_plus.on('click', events.share_google_plus_clicked);
    elements.share_facebook_button.on('click', events.share_facebook_clicked);
    elements.reveal_share_button.on('click', events.reveal_share_clicked);
    elements.login_to_ask_button.on('click', events.trigger_login);
    elements.submit.on('click', events.submit_brand_question);
    elements.merge_question_button.on('click', events.submit_merge_question);
    elements.close_merge_question.on('click', events.close_merge_question);
    elements.question_edit.on('click', events.show_edit_question);
    elements.close_edit_question.on('click', events.close_edit_question);

    elements.edit_image_button.on('click', events.launch_image_picker);

    elements.submit_form.keyup(function(event){
      if(event.keyCode == 13){
        events.submit_brand_question();
      }
    });
    elements.question_textarea.on('keyup', events.change_save_button);
    elements.edit_question_button.on('click', function() {
      events.submit_question_edit($(this).parent().parent().find('.new_title_text').val());
    });
    // Make sure things are hidden that need to be
    elements.share_container.addClass('hide');

    // append max_ts to the next link if we have it
    if(typeof vars['cardparams']['uber_ts'] !== 'undefined')
    {
      append_max_ts(vars['cardparams']['uber_ts']);
    }
  };

  $('.feedcard').each(feedcard_js);

  $(document).on('js_infinite_new_content', function(){
    $('.feedcard:not(.jscomplete)').each(feedcard_js);
  });

})(jQuery);


(function($){
  "use strict";

  var vars = {
    scroll_trigger_throttle: 1000,
    fold_threshold: 0
  };
  var funcs = {
    // call `funcs.scrollback` no faster than `vars.scroll_trigger_throttle` milliseconds
    scroll_throttle: function(){
      var wait = false;
      if (!wait) {
        funcs.scroll_callback();
        wait = true;
        setTimeout(function () {
          wait = false;
        }, vars.scroll_trigger_throttle);
      }
    },
    // test if the entire element is in the viewport
    above_the_fold: function(index, element){
      var fold = $(window).height() + $(window).scrollTop();
      return fold > ($(element).offset().top + $(element).height()) - vars.fold_threshold;
    },
    // Filter feedcards and report on the seen ones
    scroll_callback: function(){
      var $seen = $('.feedcard').filter(funcs.above_the_fold);
      $seen.addClass('seen');
      funcs.report_seen($seen);
    },
    // report on only the cards that have been seen but not reported
    report_seen: function($seen){
      var $unreported = $seen.not('.reported');
      if($unreported.length > 3){
        funcs.send_report($unreported);
        $unreported.addClass('reported');
      }
    },
    view_event_for_feedcard: function(element){
      var $feedcard = $(element);
      var card_type = $feedcard.attr("asg-card")
      var jsparams = $feedcard.data('jsparams');
      if(jsparams.hasOwnProperty('feedview_ga_event')){
        if(jsparams.feedview_ga_event.length = 3){
          return jsparams.feedview_ga_event;
        }
      }
      return ["FeedView", "unknownpage", card_type];
    },
    send_report: function(feedcards){
      var feedcard;
      var values = [];
      var view_event;
      for (var i = 0, l = feedcards.length; i < l; i++) {
        feedcard = feedcards[i];
        view_event = funcs.view_event_for_feedcard(feedcard);
        values.push(view_event[2]);
      }
      var value = values.join(",");
      _gaq.push(["_trackEvent",view_event[0], view_event[1], value]);
      console.info(["_trackEvent",view_event[0], view_event[1], value]);
    }
  };

  $(window).on('scroll', funcs.scroll_throttle);
})(jQuery);


(function($){
	var ynp_js = function(){
		var $this = $(this),
				$feedcard = $(this).closest('.feedcard');

		$feedcard.addClass('ynp_jscomplete');
		var vars = $feedcard.data('jsparams');

		vars['cardparams'] = $feedcard.data('cardparams');

		var elements = {
			ynp         : $feedcard.find(".ynp"),
			ynp_thanks	: $feedcard.find(".ynp_thanks"),
		};

		var ynp_submit = function(evt){
			$.ajax({
				url: "/solo/feedback",
				type:'POST',
				data:{
					'do':'vote',
					'depth': 0,
					'value': $(this).data('value'),
					'position': vars.cardparams.order,
					'page': vars.page,
					'mode_id': vars.mode_id,
					'question_id': vars.cardparams.content_id,
					'question_title': vars.cardparams.content_title,
					'search_url': vars.cardparams.search_url,
					'initial_event_type': "yesnopartial"
				},
				success:function(){
					elements.ynp.addClass('hide');
					elements.ynp_thanks.removeClass('hide');
				}
			});
			return false;
		};
		//EVENTS
		elements.ynp.find('button').on('click', ynp_submit);
	}
	$('.feedcard .ynp_wrapper').each(ynp_js);
	$(document).on('js_infinite_new_content', function(){
    $('.feedcard:not(.ynp_jscomplete)').each(ynp_js);
  });
})(jQuery);



/*!
	Autosize v1.18.4 - 2014-01-11
	Automatically adjust textarea height based on user input.
	(c) 2014 Jack Moore - http://www.jacklmoore.com/autosize
	license: http://www.opensource.org/licenses/mit-license.php
*/
!function(a){var b,c={className:"autosizejs",append:"",callback:!1,resizeDelay:10,placeholder:!0},d='<textarea tabindex="-1" style="position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;"/>',e=["fontFamily","fontSize","fontWeight","fontStyle","letterSpacing","textTransform","wordSpacing","textIndent"],f=a(d).data("autosize",!0)[0];f.style.lineHeight="99px","99px"===a(f).css("lineHeight")&&e.push("lineHeight"),f.style.lineHeight="",a.fn.autosize=function(d){return this.length?(d=a.extend({},c,d||{}),f.parentNode!==document.body&&a(document.body).append(f),this.each(function(){function c(){var b,c=window.getComputedStyle?window.getComputedStyle(m,null):!1;c?(b=m.getBoundingClientRect().width,0===b&&(b=parseInt(c.width,10)),a.each(["paddingLeft","paddingRight","borderLeftWidth","borderRightWidth"],function(a,d){b-=parseInt(c[d],10)})):b=Math.max(n.width(),0),f.style.width=b+"px"}function g(){var g={};if(b=m,f.className=d.className,j=parseInt(n.css("maxHeight"),10),a.each(e,function(a,b){g[b]=n.css(b)}),a(f).css(g),c(),window.chrome){var h=m.style.width;m.style.width="0px";{m.offsetWidth}m.style.width=h}}function h(){var e,h;b!==m?g():c(),f.value=!m.value&&d.placeholder?(a(m).attr("placeholder")||"")+d.append:m.value+d.append,f.style.overflowY=m.style.overflowY,h=parseInt(m.style.height,10),f.scrollTop=0,f.scrollTop=9e4,e=f.scrollTop,j&&e>j?(m.style.overflowY="scroll",e=j):(m.style.overflowY="hidden",k>e&&(e=k)),e+=o,h!==e&&(m.style.height=e+"px",p&&d.callback.call(m,m))}function i(){clearTimeout(l),l=setTimeout(function(){var a=n.width();a!==r&&(r=a,h())},parseInt(d.resizeDelay,10))}var j,k,l,m=this,n=a(m),o=0,p=a.isFunction(d.callback),q={height:m.style.height,overflow:m.style.overflow,overflowY:m.style.overflowY,wordWrap:m.style.wordWrap,resize:m.style.resize},r=n.width();n.data("autosize")||(n.data("autosize",!0),("border-box"===n.css("box-sizing")||"border-box"===n.css("-moz-box-sizing")||"border-box"===n.css("-webkit-box-sizing"))&&(o=n.outerHeight()-n.height()),k=Math.max(parseInt(n.css("minHeight"),10)-o||0,n.height()),n.css({overflow:"hidden",overflowY:"hidden",wordWrap:"break-word",resize:"none"===n.css("resize")||"vertical"===n.css("resize")?"none":"horizontal"}),"onpropertychange"in m?"oninput"in m?n.on("input.autosize keyup.autosize",h):n.on("propertychange.autosize",function(){"value"===event.propertyName&&h()}):n.on("input.autosize",h),d.resizeDelay!==!1&&a(window).on("resize.autosize",i),n.on("autosize.resize",h),n.on("autosize.resizeIncludeStyle",function(){b=null,h()}),n.on("autosize.destroy",function(){b=null,clearTimeout(l),a(window).off("resize",i),n.off("autosize").off(".autosize").css(q).removeData("autosize")}),h())})):this}}(window.jQuery||window.$);

(function($){
	var interactions_js = function(user_interactions, card_type, first_load) {
		var $this = $(user_interactions),
				$feedcard = $(user_interactions).closest(card_type);

		$feedcard.addClass('interactions_jscomplete');
		var vars = $feedcard.data('jsparams');

		vars['cardparams'] = $feedcard.data('cardparams');
		
		var elements = {
			avatar_images	: $feedcard.find('.user_interactions .avatar_images')
		};

		var image_error = function(image) {
			var avatar = $(image).parent();
			avatar.addClass('error');

			if (avatar.hasClass('hidden'))
			{
				return;
			}

			avatar.addClass('hidden');
			var hidden_count = elements.avatar_images.children('.hidden:not(.error)').length;

			if (hidden_count > 0) {
				$(elements.avatar_images.children('.hidden:not(.error)')[0]).removeClass('hidden');
			}

			var leftover_count = elements.avatar_images.children(':not(.hidden)').length;

			if (leftover_count == 0)
			{
				// Get rid of the avatar_images class since there are no images available
				elements.avatar_images.remove();
			}
		};

		if (!Boolean(elements.avatar_images)) {
			// Typecasting of boolean allows all null values to evaluate to false.
			// If we made it in here then the avatar_images div was not output for this feedcard.

			return;
		}

		//EVENTS
		// Attach on error handler for avatar images
		elements.avatar_images.find('img').on('error', function(event) {
			image_error(this);
		});

		if (first_load) {
			// Go through images that might have been broken before jquery loaded
			elements.avatar_images.find('img').each(function() {
				if (!this.complete || typeof this.naturalWidth == "undefined" || this.naturalWidth == 0) {
					image_error(this);
				}
			});
		}
	}

	$('.feedcard:not(.interactions_jscomplete) .user_interactions').each(function() {
		interactions_js(this, '.feedcard', true);
	});

	// Support for question card
	$('.question_card:not(.interactions_jscomplete) .user_interactions').each(function() {
		interactions_js(this, '.question_card', true);
	});

	$(document).on('js_infinite_new_content', function() {
    	$('.feedcard:not(.interactions_jscomplete) .user_interactions').each(function() {
			interactions_js(this, '.feedcard', false);
		});
	});
})(jQuery);



(function($){
	var flag_js = function(){
		var $this = $(this),
		$feedcard = $(this).closest('.feedcard');

		$feedcard.addClass('flag_jscomplete');
		var vars = $feedcard.data('jsparams');

		vars['cardparams'] = $feedcard.data('cardparams');

		var elements = {
			container: 		$feedcard.find('.flags_container'),
			flag: 			$feedcard.find('i.fa-flag'),
			panels: 		$feedcard.find('.accordion ul.issue_list'),
			details_link: 	$feedcard.find('.accordion section span.details_link'),
			section_head: 	$feedcard.find('.accordion section .section_head'),
			manage_button:  $feedcard.find('button.flag_btn'),
			protect_button: $this.find('button.protect_btn'),
			preserve_button:$this.find('button.preserve_btn'),
			lock: 					$this.find('i.fa-lock'),
			request: 				$this.find('p.request_link'),
			unlock_form: 			$this.find('.unlock_form'),
			unlock_reason: 			$this.find('.unlock_form textarea.unlock_reason'),
			unlock_form_button: 	$this.find('.unlock_form button.unlock_send'),
			unlock_button:  		$this.find('button.unlock_button'),
			unlock_error:  			$this.find('.lock_error'),
			unlock_thanks:  		$this.find('span.unlock_thanks')
		};

		var functions = {

			show_container: function()
			{
				elements.container.removeClass("fade_then_hide");
			},

			hide_container: function()
			{
				elements.container.addClass("fade_then_hide");
			},

			open_panel : function()
			{
				if($(this).hasClass('open'))
				{
					return false;
				}

				elements.panels.slideUp();
	    		$(this).next().slideDown();
	    		elements.details_link.show();
	   			$(this).find('span.details_link').hide();
	   			elements.section_head.removeClass('open');
	    		$(this).addClass('open');
	    		return false;
			},

			open_modal : function()
			{
				$(document).trigger({ type: 'open_flag_modal', cur_id: vars.cardparams.content_id, mc_key: vars.cardparams.mc });
				functions.hide_container();
			},

			open_protect_modal : function()
			{
				$(document).trigger({ type: 'open_protect_modal', cur_id: vars.cardparams.content_id, mc_key: vars.cardparams.mc });
				functions.hide_container();
			},

			open_preserve_modal : function()
			{
				$(document).trigger({ type: 'open_preserve_modal', cur_id: vars.cardparams.content_id, mc_key: vars.cardparams.mc });
				functions.hide_container();
			},

			show_unlock_form: function()
			{
				elements.unlock_form.removeClass('hide');
				elements.request.addClass('hide');
			},

			unlock_question: function()
			{
				var type = $(this).data('type'),
					endpoint = type == 'protected' ? '/ajax/protectQuestion.php' : '/ajax/preserveQuestion.php';
				var data = {
				 	'title': encodeURIComponent(vars['cardparams'].content_slug),
				 	'etag': encodeURIComponent(vars['cardparams'].content_etag),
				 	'jsonly': 1,
				 	'media': 'screen'
				};

				if(type == "protected"){
					data.toProtect = 0;
				}
				else{
					data.action = "unlock"
				}

				$.ajax({
					url: endpoint,
					type:'POST',
					data: data,
					dataType : 'json',
					success:function(response){
						if(response.status == 200){
								//break cache for feed
							$.ajax({
								url: "/endpoint/memcache/delete",
								type:'POST',
								data: {
									'key': vars.cardparams.mc
								},
								dataType : 'json',
								success:function(response)
								{
									if (type == 'protected'){
										$.ajax({
											url: "/endpoint/questions/locks/reasons/delete",
											type:'POST',
											data: {
												'questions_id': vars['cardparams'].content_id
											},
											dataType : 'json',
											success:function(response)
											{
												_gaq.push(['_trackEvent', 'lock_system', vars.page + "/" + vars.lmi, 'question_unprotected', parseInt(vars['cardparams'].content_id)]);
												_gaq.push(function() {
													location.reload();
												});
											}
										});
									}
									else {
										_gaq.push(['_trackEvent', 'lock_system', vars.page + "/" + vars.lmi, 'question_unpreserved', parseInt(vars['cardparams'].content_id)]);
										_gaq.push(function() {
											location.reload();
										});
									}
								}
							});
						}
						else if(response.status == 412001){
							var message = 'This question has changed. Try unlocking <a href="' + vars.cardparams.content_url + '">here</a>';
							elements.unlock_error.html(message);
						}
						else{
							var message = 'Sorry, there was a problem unlocking the question.';
							elements.unlock_error.html(message);
						}

					},
					error:function(response){
						var message = 'Sorry, there was a problem unlocking the question.';
						elements.unlock_error.html(message);
					}
				});
			},

			send_request: function()
			{
				elements.unlock_form.addClass("hide");
				elements.unlock_thanks.removeClass("hide");
			},

			reason_keyup: function()
			{
				elements.unlock_form_button.prop('disabled',(elements.unlock_reason.val().length == 0));
			},

			manage_click: function(e)
			{
				e.stopPropagation();
				if( !elements.container.hasClass("fade_then_hide") ) {
					functions.hide_container();
				}
				else {
					functions.show_container();
				}
			}
		};

		elements.panels.hide().first().show();
		elements.details_link.first().hide();
		elements.section_head.first().addClass('open');

		// Manage opening and closing of the popup..
		elements.flag.on('click', functions.manage_click);
		elements.lock.on('click', functions.manage_click);
		elements.container.on('click', function(e) {
			e.stopPropagation();
		});
		$("body").on('click', function() {
			functions.hide_container();
		});
		$feedcard.on('mouseleave', function () {
			if (elements.container.hasClass('fade_then_hide') === false) {
				functions.hide_container();
			}
		});
		// ends.

		elements.request.on('click', functions.show_unlock_form);
		elements.unlock_button.on('click', functions.unlock_question);
		elements.unlock_reason.on('keyup', functions.reason_keyup);
		elements.unlock_form_button.on('click', functions.send_request);
		elements.section_head.on('click', functions.open_panel);
		elements.manage_button.on('click', functions.open_modal);
		elements.protect_button.on('click', functions.open_protect_modal);
		elements.preserve_button.on('click', functions.open_preserve_modal);
	}
	$('.feedcard .flag_wrapper').each(flag_js);
	$(document).on('js_infinite_new_content', function(){
    $('.feedcard:not(.flag_jscomplete)').each(flag_js);
  });
})(jQuery);



(function($){
	var submit_answer_js = function(){
		var $this = $(this),
			$feedcard = $(this).closest('.feedcard'),
			vars = $feedcard.data('jsparams'),
			index = 0;

		$feedcard.addClass('submit_answer_jscomplete');

		vars['cardparams'] = $feedcard.data('cardparams');

		var elements = {
			frame_div		: $feedcard.find('.frame'),
			hgroup_div		: $feedcard.find('.hgroup'),
			content_div		: $feedcard.find('.content'),
			fgroup_div		: $feedcard.find('.fgroup'),
			error_div		: $feedcard.find('.error'),
			answer_button	: $feedcard.find('.answer'),
			answer_field	: $feedcard.find('.uq_answer'),
			overlay			: $feedcard.find('.overlay'),
			nicEdit			: $feedcard.find('.nicEdit'),
			super_options	: $feedcard.find('.show_options .options'),
			expert_response		: $feedcard.find('.expert_response'),
			answer_container	: $feedcard.find('.answer_container'),

			overlay_close	: $feedcard.find('.overlay .close')
		};

		var overlay_hide_delay_secs = 6;

		var functions = {
			submit_answer : function(answer_text) {
				gatracking.fire(['_trackEvent','unanswered_q_response','answered']);
				var question = vars['cardparams']['content_title'];

				if (typeof question == 'string')
				{
					if (question.indexOf('?') + 1 == question.length)
					{
						question = question.substring(0, question.length - 1);
					}
				}

				var data = {
					'question' : question,
					'etag'     : vars['cardparams']['content_etag'],
					'answer'   : answer_text
				};

				var module_div;
				var module_type = 'undefined';

				module_div = $(this).closest('.module.feedcards_wikilite_usercategories_unanswered');

				// Typecasting of boolean allows all null values to evaluate to false
				if (Boolean(module_div)) {
					module_type = 'feedcards/wikilite/usercategories/unanswered';
				} else {
					module_div = $(this).closest('.module.feedcards_wikilite_unanswered');

					if (Boolean(module_div)) {
						module_type = 'feedcards/wikilite/unanswered';
					}
				}

				var response = $.ajax({
					type: 'POST',
					async: false,
					url: '/solo/ajax/question/answer',
					data: data,
					success: function(respdata) {
						if (typeof respdata.type != 'undefined' && respdata.type == 'success') {
							if(module_type == 'undefined' || vars.show_next_wl_usercat_q === "no") {
								elements.frame_div.addClass('has_answered');
								elements.error_div.hide();
								elements.super_options.hide();
								elements.super_options.next('.selectify-select').addClass('hide');
								functions.show_with_timeout(elements.overlay, vars.module_configs.overlay_timeout);
								functions.remove_feedcard_with_timeout(vars.module_configs.overlay_timeout);

							}
							else {
								// 'unanswered_question' card, on successfully submitting the answer,
								// just get the next card and display it here.
								elements.hgroup_div.hide();
								elements.content_div.hide();
								elements.fgroup_div.hide();
								var url = '/solo/ajax/' + module_type;
								
								$.ajax({
									type: 'GET',
									url: url,
									data: data,
									success: function(resp) {
										if(resp.length) {
											var new_uq = resp[0];
											vars.cardparams.content_etag  = new_uq.content_etag;
											vars.cardparams.content_title  = new_uq.content_title;
											vars.cardparams.content_id     = new_uq.content_id;
											vars.cardparams.next_header_link_text = new_uq.header_link_text;
											vars.cardparams.next_header_link_url  = new_uq.header_link_url;
											vars.cardparams.content_text   = new_uq.content_text;
											vars.cardparams.content_url    = new_uq.content_url;
											vars.cardparams.search_url     = new_uq.search_url;
											vars.cardparams.image1_url     = new_uq.image1_url;

											// Now change the values seen on the UI..
											elements.answer_field.val('');
											$feedcard.find('.frame a.category_name').attr("href", vars.cardparams.next_header_link_url);
											$feedcard.find('.frame a.category_name').text(vars.cardparams.next_header_link_text);
											$feedcard.find('.frame a.title_link').attr("href", vars.cardparams.content_url);
											$feedcard.find('.frame a.title_link').text(vars.cardparams.content_title);

											elements.hgroup_div.show();
											elements.content_div.show();
											elements.fgroup_div.show();
											elements.frame_div.addClass('has_answered');

											if(vars.cardparams.header_link_text != "Uncategorized"){
												elements.overlay.find('span.see_more_qs a').text(vars.cardparams.header_link_text);
											}
											else {
												elements.overlay.find('span.see_more_qs a').text("Categories You Follow");
											}
											vars.cardparams.header_link_text = vars.cardparams.next_header_link_text;
											functions.show_with_timeout(elements.overlay, vars.module_configs.overlay_timeout);
										}
										else {
											elements.frame_div.addClass('has_answered');
											elements.hgroup_div.hide();
											elements.content_div.hide();
											elements.fgroup_div.hide();
											elements.error_div.hide();
										}
										functions.nicEdit_clear();
									},
									error: function(data) {
										elements.error_div.html('We seem to be having difficulty saving your answer. Please refresh the page or contact us.');
										elements.error_div.removeClass('hide');
										elements.frame_div.addClass('contains_error');
									},
									dataType: 'json'
								});
							}
						}
						else if (typeof respdata.type != 'undefined' && respdata.type == 'error') {
							if (typeof respdata.error_message != 'undefined') {
								elements.error_div.html(respdata.error_message);
								elements.error_div.removeClass('hide');
								elements.frame_div.addClass('contains_error');
							}
							if(typeof respdata.new_answer != 'undefined') {
								elements.answer_area.val(respdata.new_answer);
							}
						}
						functions.nicEdit_clear();
					},
					error: function(data) {
						elements.error_div.html('We seem to be having difficulty saving your answer. Please refresh the page or contact us.');
						elements.error_div.removeClass('hide');
						elements.frame_div.addClass('contains_error');
					},
					dataType: 'json'
				});
			},

			submit_answer_vague : function() {
				var text =  $feedcard.find('.answer_container .nicEdit-main').html();
				gatracking.fire(['_trackEvent','unanswered_q_response','ask_for_more_detail']);
				// ajax call to solo/ajax/question/answer/vague
				$.ajax({
					url      : "/solo/ajax/question/answer/vague",
					type     : 'POST',
					dataType : 'json',
					data     : {
						'answer'    : text,
						'etag'      : $feedcard.find('fieldset.answer_container input[name=question_etag]').val(),
						'question'  : $feedcard.find('fieldset.answer_container input[name=question_title]').val()
					},
					success : function(response)
					{
						window.location.reload(true);
					},
					error : function(response)
					{
						window.location.reload(true);
					}
				});
			},
			submit_answer_challenging : function() {
				gatracking.fire(['_trackEvent','unanswered_q_response','requires_expert_response']);

				// ajax call to solo/ajax/question/answer/challenging
				$.ajax({
					url      : "/solo/ajax/question/answer/challenging",
					type     : 'POST',
					dataType : 'json',
					data     : {
						'question'  : $feedcard.find('fieldset.answer_container input[name=question_title]').val()
					},
					success : function(response)
					{
						window.location.reload(true);
					},
					error : function(response)
					{
						window.location.reload(true);
					}
				});
			},
			super_options_changed : function() {
				var text_value = elements.super_options.val();
				elements.expert_response.hide();
				elements.answer_container.show();

				$feedcard.removeClass('ask_for_more_detail requires_expert_response');
				switch (text_value) {
					case 'answer_it':
						text = elements.nicEdit.val();
						$feedcard.find('.nicEdit-main').html(text);
						break;
					case 'ask_for_more_detail':
						$feedcard.addClass('ask_for_more_detail');
						text = 'The Answers community requested more information for this question. Please edit your question to include more context.';
						$feedcard.find('.nicEdit-main').html(text);
						break;
					case 'requires_expert_response':
						elements.expert_response.show();
						elements.answer_container.hide();
						$feedcard.addClass('requires_expert_response');
						break;
				}
			},
			answer_btn_clicked : function() {
				var option = elements.super_options.val();
				if(typeof option === 'undefined' || option == 'answer_it')
				{
					var answer;
					if(elements.nicEdit.length !== 0)
					{
						var editor = $(this).closest('.feedcard').find('.nicEdit-main');
						answer = $(editor).html();
						functions.submit_answer.call($feedcard, answer);
					}
					else
					{
						answer = elements.answer_field.val();
						functions.submit_answer(answer);
					}
				}
				else if (option == 'ask_for_more_detail')
				{
					functions.submit_answer_vague();
				}
				else
				{
					functions.submit_answer_challenging();
				}
			},
			nicEdit_focus : function() {
				var editor = $(this).closest('.feedcard').find('.nicEdit-main');
				if(editor.html() == elements.nicEdit.html())
				{
					functions.nicEdit_clear();
					editor.attr('tabindex', '0').focus();
				}
			},
			nicEdit_blur :function () {
				var editor = $(this).closest('.feedcard').find('.nicEdit-main');
				if(editor.html() === "")
				{
					editor.html(elements.nicEdit.html());
				}
			},
			nicEdit_clear : function() {
				var editor = $feedcard.find('.nicEdit-main');
				editor.html('');
				elements.nicEdit.html('Answer this question...');
			},
			show_with_timeout : function(element, timer) {
				element.show();
				// hide again after timer
				if(!isNaN(timer) && timer > 0) {
					setTimeout(function() {
						element.hide();
					}, timer);
				}
			},
			remove_feedcard_with_timeout : function(timer) {
				if(!isNaN(timer) && timer > 0) {
					setTimeout(function() {
						$feedcard.remove();
					}, timer);
				} else {
					$feedcard.remove();
				}
			}
		};
		// EVENTS
		elements.answer_field.keyup(function(event) {
			if(event.keyCode == 13){
				var answer = elements.answer_field.val();
				functions.submit_answer.call($feedcard, answer);
			}
		});

		elements.expert_response.hide();

		elements.super_options.on('selectify.change', functions.super_options_changed);

		elements.answer_button.on('click', functions.answer_btn_clicked);

		$this.on('focus click mousedown', '.nicEdit-main', functions.nicEdit_focus);

		$this.on('blur', '.nicEdit-main', functions.nicEdit_blur);

		// elements.overlay.hide();
		// overlay close btn
		elements.overlay_close.on('click', function(e) {
			console.log('overlay close '+e.type);
			$(this).parent('.overlay').hide();
		});

	};


	$('.feedcard .user_input').each(submit_answer_js);
	$(document).on('js_infinite_new_content', function() {
		$('.feedcard:not(.submit_answer_jscomplete) .user_input').each(submit_answer_js);
	});
})(jQuery);


/* Placeholders.js v3.0.2 */
(function(t){"use strict";function e(t,e,r){return t.addEventListener?t.addEventListener(e,r,!1):t.attachEvent?t.attachEvent("on"+e,r):void 0}function r(t,e){var r,n;for(r=0,n=t.length;n>r;r++)if(t[r]===e)return!0;return!1}function n(t,e){var r;t.createTextRange?(r=t.createTextRange(),r.move("character",e),r.select()):t.selectionStart&&(t.focus(),t.setSelectionRange(e,e))}function a(t,e){try{return t.type=e,!0}catch(r){return!1}}t.Placeholders={Utils:{addEventListener:e,inArray:r,moveCaret:n,changeType:a}}})(this),function(t){"use strict";function e(){}function r(){try{return document.activeElement}catch(t){}}function n(t,e){var r,n,a=!!e&&t.value!==e,u=t.value===t.getAttribute(V);return(a||u)&&"true"===t.getAttribute(P)?(t.removeAttribute(P),t.value=t.value.replace(t.getAttribute(V),""),t.className=t.className.replace(R,""),n=t.getAttribute(z),parseInt(n,10)>=0&&(t.setAttribute("maxLength",n),t.removeAttribute(z)),r=t.getAttribute(D),r&&(t.type=r),!0):!1}function a(t){var e,r,n=t.getAttribute(V);return""===t.value&&n?(t.setAttribute(P,"true"),t.value=n,t.className+=" "+I,r=t.getAttribute(z),r||(t.setAttribute(z,t.maxLength),t.removeAttribute("maxLength")),e=t.getAttribute(D),e?t.type="text":"password"===t.type&&K.changeType(t,"text")&&t.setAttribute(D,"password"),!0):!1}function u(t,e){var r,n,a,u,i,l,o;if(t&&t.getAttribute(V))e(t);else for(a=t?t.getElementsByTagName("input"):f,u=t?t.getElementsByTagName("textarea"):h,r=a?a.length:0,n=u?u.length:0,o=0,l=r+n;l>o;o++)i=r>o?a[o]:u[o-r],e(i)}function i(t){u(t,n)}function l(t){u(t,a)}function o(t){return function(){b&&t.value===t.getAttribute(V)&&"true"===t.getAttribute(P)?K.moveCaret(t,0):n(t)}}function c(t){return function(){a(t)}}function s(t){return function(e){return A=t.value,"true"===t.getAttribute(P)&&A===t.getAttribute(V)&&K.inArray(C,e.keyCode)?(e.preventDefault&&e.preventDefault(),!1):void 0}}function d(t){return function(){n(t,A),""===t.value&&(t.blur(),K.moveCaret(t,0))}}function v(t){return function(){t===r()&&t.value===t.getAttribute(V)&&"true"===t.getAttribute(P)&&K.moveCaret(t,0)}}function g(t){return function(){i(t)}}function p(t){t.form&&(T=t.form,"string"==typeof T&&(T=document.getElementById(T)),T.getAttribute(U)||(K.addEventListener(T,"submit",g(T)),T.setAttribute(U,"true"))),K.addEventListener(t,"focus",o(t)),K.addEventListener(t,"blur",c(t)),b&&(K.addEventListener(t,"keydown",s(t)),K.addEventListener(t,"keyup",d(t)),K.addEventListener(t,"click",v(t))),t.setAttribute(j,"true"),t.setAttribute(V,x),(b||t!==r())&&a(t)}var f,h,b,m,A,y,E,x,L,T,S,N,w,B=["text","search","url","tel","email","password","number","textarea"],C=[27,33,34,35,36,37,38,39,40,8,46],k="#ccc",I="placeholdersjs",R=RegExp("(?:^|\\s)"+I+"(?!\\S)"),V="data-placeholder-value",P="data-placeholder-active",D="data-placeholder-type",U="data-placeholder-submit",j="data-placeholder-bound",q="data-placeholder-focus",Q="data-placeholder-live",z="data-placeholder-maxlength",F=document.createElement("input"),G=document.getElementsByTagName("head")[0],H=document.documentElement,J=t.Placeholders,K=J.Utils;if(J.nativeSupport=void 0!==F.placeholder,!J.nativeSupport){for(f=document.getElementsByTagName("input"),h=document.getElementsByTagName("textarea"),b="false"===H.getAttribute(q),m="false"!==H.getAttribute(Q),y=document.createElement("style"),y.type="text/css",E=document.createTextNode("."+I+" { color:"+k+"; }"),y.styleSheet?y.styleSheet.cssText=E.nodeValue:y.appendChild(E),G.insertBefore(y,G.firstChild),w=0,N=f.length+h.length;N>w;w++)S=f.length>w?f[w]:h[w-f.length],x=S.attributes.placeholder,x&&(x=x.nodeValue,x&&K.inArray(B,S.type)&&p(S));L=setInterval(function(){for(w=0,N=f.length+h.length;N>w;w++)S=f.length>w?f[w]:h[w-f.length],x=S.attributes.placeholder,x?(x=x.nodeValue,x&&K.inArray(B,S.type)&&(S.getAttribute(j)||p(S),(x!==S.getAttribute(V)||"password"===S.type&&!S.getAttribute(D))&&("password"===S.type&&!S.getAttribute(D)&&K.changeType(S,"text")&&S.setAttribute(D,"password"),S.value===S.getAttribute(V)&&(S.value=x),S.setAttribute(V,x)))):S.getAttribute(P)&&(n(S),S.removeAttribute(V));m||clearInterval(L)},100)}K.addEventListener(t,"beforeunload",function(){J.disable()}),J.disable=J.nativeSupport?e:i,J.enable=J.nativeSupport?e:l}(this),function(t){"use strict";var e=t.fn.val,r=t.fn.prop;Placeholders.nativeSupport||(t.fn.val=function(t){var r=e.apply(this,arguments),n=this.eq(0).data("placeholder-value");return void 0===t&&this.eq(0).data("placeholder-active")&&r===n?"":r},t.fn.prop=function(t,e){return void 0===e&&this.eq(0).data("placeholder-active")&&"value"===t?"":r.apply(this,arguments)})}(jQuery);


(function($){
	$('.module.followlist_experts').each( function() {
		var $this	= $(this);
		var params	= $this.data('jsparams');
		var eles	= {
			selected : '',
			login_link: $this.find('a.login_required.login_link'),
			signup_link: $this.find('a.login_required.signup_link'),
			follow_button: $this.find('button.follow_button')
		};
		var functions= {
			follow_expert: function(item) {
				var expert_id = [item.data('id')];
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'follow|expert|'+expert_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: expert_id,
						type: 'User'
					}
				});
			},
			unfollow_expert: function(item) {
				var expert_id = [item.data('id')];
				var removing_expert_follow = 'yes';
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'unfollow|expert|'+expert_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_expert_follow,
						ids: expert_id,
						type: 'User'
					}
				});
			},
			handle_click: function(item) {
				if(item.hasClass('selected')) {
					item.removeClass('selected');
					item.text('Follow');
					functions.unfollow_expert(item);
				}
				else {
					item.addClass('selected');
					item.text('Following');
					functions.follow_expert(item);
				}
			}
		};
		$( document ).on( 'login_failure', function() {
			eles.selected = '';
		});
		eles.follow_button.on( 'click', function() {
			if(!params.logged_in) {
				eles.selected = $(this);
				$(document).trigger("login_required");
			}
			else {
				eles.selected = '';
				functions.handle_click($(this));
			}
		});
		$(document).on('login_successful', function(){
			if(typeof eles.selected != 'undefined'&&eles.selected!=='') {
				functions.handle_click(eles.selected);
				eles.selected = '';
			}
		});
		eles.login_link.on('click', function() {
			$(document).trigger("login_required", "login");
		});
		eles.signup_link.on('click', function() {
			$(document).trigger("login_required", "signup");
		});
	});
})(jQuery);


(function($){
	$('.module.followlist_experts_handpicked').each( function() {
		var $this	= $(this);
		var params	= $this.data('jsparams');
		var eles	= {
			login_link:    $this.find('a.login_required.login_link'),
			signup_link:   $this.find('a.login_required.signup_link'),
			follow_button: $this.find('button.follow_button')
		};

		var functions= {
			follow_expert: function(item) {
				var expert_id = item.data('ufid');
				var type = item.data('ufkey');
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'follow|handpicked_'+type+'|'+expert_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: item.data('ufid'),
						type: item.data('ufkey')
					}
				});
			},
			unfollow_expert: function(item) {
				var expert_id = item.data('ufid');
				var type = item.data('ufkey');
				var removing_expert_follow = 'yes';
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'unfollow|handpicked_'+type+'|'+expert_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_expert_follow,
						ids: item.data('ufid'),
						type: item.data('ufkey')
					}
				});
			},
			handle_click: function(item) {
				if(item.hasClass('selected')) {
					item.removeClass('selected');
					item.text('Follow');
					functions.unfollow_expert(item);
				}
				else {
					item.addClass('selected');
					item.text('Following');
					functions.follow_expert(item);
				}
			}
		};

		$( document ).on( 'login_failure', function() {
			eles.selected = '';
		});

		eles.follow_button.on( 'click', function() {
			if(!params.logged_in) {
				eles.selected = $(this);
				$(document).trigger("login_required");
			}
			else {
				eles.selected = '';
				functions.handle_click($(this));
			}
		});

		$(document).on('login_successful', function(){
			if(typeof eles.selected != 'undefined'&&eles.selected!=='') {
				functions.handle_click(eles.selected);
				eles.selected = '';
			}
		});

		eles.login_link.on('click', function() {
			$(document).trigger("login_required", "login");
		});

		eles.signup_link.on('click', function() {
			$(document).trigger("login_required", "signup");
		});

	});
})(jQuery);

(function($){
	$('.module.user_content_authority').each( function() {
		var $this = $(this);

		var params = $this.data('jsparams');

		var eles = {
			selected : '',
			follow_button: 'button.follow_button',
			bio_more: '.bio_button.more',
			bio_less: '.bio_button.less',
			bio_block: '.bio_block'
		};

		var functions = {
			show_bio: function() {
				$this.find(eles.bio_more).addClass('hide');
				$this.find(eles.bio_less).removeClass('hide');
				$this.find(eles.bio_block).removeClass('hide');
			},
			hide_bio: function() {
				$this.find(eles.bio_less).addClass('hide');
				$this.find(eles.bio_more).removeClass('hide');
				$this.find(eles.bio_block).addClass('hide');
			},
			follow_expert: function(item) {
				var expert_id = [item.data('id')];
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: expert_id,
						type: 'User'
					}
				});
			},
			unfollow_expert: function(item) {
				var expert_id = [item.data('id')];
				var removing_expert_follow = 'yes';
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_expert_follow,
						ids: expert_id,
						type: 'User'
					}
				});
			},
			handle_click: function(item) {
				if(item.hasClass('is_followed')) {
					item.removeClass('is_followed');
					item.attr('title', 'Click here to follow');
					item.attr('asg-button', 'roundicon plus');
					functions.unfollow_expert(item);
				}
				else {
					item.addClass('is_followed');
					item.attr('title', 'Click here to unfollow');
					item.attr('asg-button', 'roundicon check');
					functions.follow_expert(item);
				}
			},
			handle_slideshow_change: function() {
				if (typeof desktop_slide === 'undefined' || desktop_slide === null)
				{
					return false;
				}
				var current_batch = desktop_slide.current_batch();
				var id = functions.get_id_from_batch(current_batch);
				functions.load_new_authority(id);
			},
			get_id_from_batch: function(batch) {
				try {
					if (typeof batch === 'undefined' || batch === null) {
						return 0;
					}
					var id = $(batch).data('batch-id');
					if (typeof id === 'undefined' || id === null) {
						return 0;
					}
					return id;
				}
				catch (err){
					// here just in case, keeps rest of javascript from possibly breaking
				}
				return 0;
			},
			load_new_authority: function(id) {
				if (id === 0)
				{
					return;
				}
				$.ajax({
					url: "/solo/user/content/authority",
					dataType: "html",
					type: "get",
					data: {
						authority_guide_id: encodeURIComponent(id),
						authority_type: params.authority_type,
						bio_length_in_words: params.bio_length_in_words
					},
					success: function(response) {
						if(response) {
							$this.find('.frame').remove();
							$this.append(response);
						}
					}
				});
			}
		};

		// HANDLE FOLLOW/UNFOLLOW CLICK - LOGIN IF NOT ALREADY
		$this.on( 'click', eles.follow_button, function() {
			if(!params.logged_in) {
				eles.selected = $(this);
				$(document).trigger("login_required");
				window.scrollTo(0,0);
			}
			else {
				eles.selected = '';
				functions.handle_click($(this));
			}
		});

		$this.on( 'click', eles.bio_more, functions.show_bio );
		$this.on( 'click', eles.bio_less, functions.hide_bio );

		// HANDLE GUTE SLIDESHOW EVENTS
		$(document).on('desktop_slide.prevarticle desktop_slide.nextarticle', functions.handle_slideshow_change);

		// HANDLE LOGIN EVENTS
		$( document ).on( 'login_failure', function() {
			eles.selected = '';
		});
		$(document).on('login_successful', function(){
			if(typeof eles.selected != 'undefined' && eles.selected!=='') {
				functions.handle_click(eles.selected);
				eles.selected = '';
			}
		});
	});
})(jQuery);


// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns are not implemented.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn't correct.
// * Painting mode isn't implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// Only add this code if we do not already have a canvas implementation
if (!document.createElement('canvas').getContext) {

(function() {

  // alias some functions to make (compiled) code shorter
  var m = Math;
  var mr = m.round;
  var ms = m.sin;
  var mc = m.cos;
  var abs = m.abs;
  var sqrt = m.sqrt;

  // this is used for sub pixel precision
  var Z = 10;
  var Z2 = Z / 2;

  /**
   * This funtion is assigned to the <canvas> elements as element.getContext().
   * @this {HTMLElement}
   * @return {CanvasRenderingContext2D_}
   */
  function getContext() {
    return this.context_ ||
        (this.context_ = new CanvasRenderingContext2D_(this));
  }

  var slice = Array.prototype.slice;

  /**
   * Binds a function to an object. The returned function will always use the
   * passed in {@code obj} as {@code this}.
   *
   * Example:
   *
   *   g = bind(f, obj, a, b)
   *   g(c, d) // will do f.call(obj, a, b, c, d)
   *
   * @param {Function} f The function to bind the object to
   * @param {Object} obj The object that should act as this when the function
   *     is called
   * @param {*} var_args Rest arguments that will be used as the initial
   *     arguments when the function is called
   * @return {Function} A new function that has bound this
   */
  function bind(f, obj, var_args) {
    var a = slice.call(arguments, 2);
    return function() {
      return f.apply(obj, a.concat(slice.call(arguments)));
    };
  }

  var G_vmlCanvasManager_ = {
    init: function(opt_doc) {
      if (/MSIE/.test(navigator.userAgent) && !window.opera) {
        var doc = opt_doc || document;
        // Create a dummy element so that IE will allow canvas elements to be
        // recognized.
        doc.createElement('canvas');
        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
      }
    },

    init_: function(doc) {
      // create xmlns
      if (!doc.namespaces['g_vml_']) {
        doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',
                           '#default#VML');

      }
      if (!doc.namespaces['g_o_']) {
        doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',
                           '#default#VML');
      }

      // Setup default CSS.  Only add one style sheet per document
      if (!doc.styleSheets['ex_canvas_']) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = 'ex_canvas_';
        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
            // default size is 300x150 in Gecko and Opera
            'text-align:left;width:300px;height:150px}' +
            'g_vml_\\:*{behavior:url(#default#VML)}' +
            'g_o_\\:*{behavior:url(#default#VML)}';

      }

      // find all canvas elements
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    },

    /**
     * Public initializes a canvas element so that it can be used as canvas
     * element from now on. This is called automatically before the page is
     * loaded but if you are creating elements using createElement you need to
     * make sure this is called on the element.
     * @param {HTMLElement} el The canvas element to initialize.
     * @return {HTMLElement} the element that was created.
     */
    initElement: function(el) {
      if (!el.getContext) {

        el.getContext = getContext;

        // Remove fallback content. There is no way to hide text nodes so we
        // just remove all childNodes. We could hide all elements and remove
        // text nodes but who really cares about the fallback content.
        el.innerHTML = '';

        // do not use inline function because that will leak memory
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);

        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setWidth_(attrs.width.nodeValue);
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          // TODO: use runtimeStyle and coordsize
          // el.getContext().setHeight_(attrs.height.nodeValue);
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
        //el.getContext().setCoordsize_()
      }
      return el;
    }
  };

  function onPropertyChange(e) {
    var el = e.srcElement;

    switch (e.propertyName) {
      case 'width':
        el.style.width = el.attributes.width.nodeValue + 'px';
        el.getContext().clearRect();
        break;
      case 'height':
        el.style.height = el.attributes.height.nodeValue + 'px';
        el.getContext().clearRect();
        break;
    }
  }

  function onResize(e) {
    var el = e.srcElement;
    if (el.firstChild) {
      el.firstChild.style.width =  el.clientWidth + 'px';
      el.firstChild.style.height = el.clientHeight + 'px';
    }
  }

  G_vmlCanvasManager_.init();

  // precompute "00" to "FF"
  var dec2hex = [];
  for (var i = 0; i < 16; i++) {
    for (var j = 0; j < 16; j++) {
      dec2hex[i * 16 + j] = i.toString(16) + j.toString(16);
    }
  }

  function createMatrixIdentity() {
    return [
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ];
  }

  function matrixMultiply(m1, m2) {
    var result = createMatrixIdentity();

    for (var x = 0; x < 3; x++) {
      for (var y = 0; y < 3; y++) {
        var sum = 0;

        for (var z = 0; z < 3; z++) {
          sum += m1[x][z] * m2[z][y];
        }

        result[x][y] = sum;
      }
    }
    return result;
  }

  function copyState(o1, o2) {
    o2.fillStyle     = o1.fillStyle;
    o2.lineCap       = o1.lineCap;
    o2.lineJoin      = o1.lineJoin;
    o2.lineWidth     = o1.lineWidth;
    o2.miterLimit    = o1.miterLimit;
    o2.shadowBlur    = o1.shadowBlur;
    o2.shadowColor   = o1.shadowColor;
    o2.shadowOffsetX = o1.shadowOffsetX;
    o2.shadowOffsetY = o1.shadowOffsetY;
    o2.strokeStyle   = o1.strokeStyle;
    o2.globalAlpha   = o1.globalAlpha;
    o2.arcScaleX_    = o1.arcScaleX_;
    o2.arcScaleY_    = o1.arcScaleY_;
    o2.lineScale_    = o1.lineScale_;
  }

  function processStyle(styleString) {
    var str, alpha = 1;

    styleString = String(styleString);
    if (styleString.substring(0, 3) == 'rgb') {
      var start = styleString.indexOf('(', 3);
      var end = styleString.indexOf(')', start + 1);
      var guts = styleString.substring(start + 1, end).split(',');

      str = '#';
      for (var i = 0; i < 3; i++) {
        str += dec2hex[Number(guts[i])];
      }

      if (guts.length == 4 && styleString.substr(3, 1) == 'a') {
        alpha = guts[3];
      }
    } else {
      str = styleString;
    }

    return {color: str, alpha: alpha};
  }

  function processLineCap(lineCap) {
    switch (lineCap) {
      case 'butt':
        return 'flat';
      case 'round':
        return 'round';
      case 'square':
      default:
        return 'square';
    }
  }

  /**
   * This class implements CanvasRenderingContext2D interface as described by
   * the WHATWG.
   * @param {HTMLElement} surfaceElement The element that the 2D context should
   * be associated with
   */
  function CanvasRenderingContext2D_(surfaceElement) {
    this.m_ = createMatrixIdentity();

    this.mStack_ = [];
    this.aStack_ = [];
    this.currentPath_ = [];

    // Canvas context properties
    this.strokeStyle = '#000';
    this.fillStyle = '#000';

    this.lineWidth = 1;
    this.lineJoin = 'miter';
    this.lineCap = 'butt';
    this.miterLimit = Z * 1;
    this.globalAlpha = 1;
    this.canvas = surfaceElement;

    var el = surfaceElement.ownerDocument.createElement('div');
    el.style.width =  surfaceElement.clientWidth + 'px';
    el.style.height = surfaceElement.clientHeight + 'px';
    el.style.overflow = 'hidden';
    el.style.position = 'absolute';
    surfaceElement.appendChild(el);

    this.element_ = el;
    this.arcScaleX_ = 1;
    this.arcScaleY_ = 1;
    this.lineScale_ = 1;
  }

  var contextPrototype = CanvasRenderingContext2D_.prototype;
  contextPrototype.clearRect = function() {
    this.element_.innerHTML = '';
  };

  contextPrototype.beginPath = function() {
    // TODO: Branch current matrix so that save/restore has no effect
    //       as per safari docs.
    this.currentPath_ = [];
  };

  contextPrototype.moveTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});
    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.lineTo = function(aX, aY) {
    var p = this.getCoords_(aX, aY);
    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});

    this.currentX_ = p.x;
    this.currentY_ = p.y;
  };

  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                            aCP2x, aCP2y,
                                            aX, aY) {
    var p = this.getCoords_(aX, aY);
    var cp1 = this.getCoords_(aCP1x, aCP1y);
    var cp2 = this.getCoords_(aCP2x, aCP2y);
    bezierCurveTo(this, cp1, cp2, p);
  };

  // Helper function that takes the already fixed cordinates.
  function bezierCurveTo(self, cp1, cp2, p) {
    self.currentPath_.push({
      type: 'bezierCurveTo',
      cp1x: cp1.x,
      cp1y: cp1.y,
      cp2x: cp2.x,
      cp2y: cp2.y,
      x: p.x,
      y: p.y
    });
    self.currentX_ = p.x;
    self.currentY_ = p.y;
  }

  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
    // the following is lifted almost directly from
    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

    var cp = this.getCoords_(aCPx, aCPy);
    var p = this.getCoords_(aX, aY);

    var cp1 = {
      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
    };
    var cp2 = {
      x: cp1.x + (p.x - this.currentX_) / 3.0,
      y: cp1.y + (p.y - this.currentY_) / 3.0
    };

    bezierCurveTo(this, cp1, cp2, p);
  };

  contextPrototype.arc = function(aX, aY, aRadius,
                                  aStartAngle, aEndAngle, aClockwise) {
    aRadius *= Z;
    var arcType = aClockwise ? 'at' : 'wa';

    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

    // IE won't render arches drawn counter clockwise if xStart == xEnd.
    if (xStart == xEnd && !aClockwise) {
      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                       // that can be represented in binary
    }

    var p = this.getCoords_(aX, aY);
    var pStart = this.getCoords_(xStart, yStart);
    var pEnd = this.getCoords_(xEnd, yEnd);

    this.currentPath_.push({type: arcType,
                           x: p.x,
                           y: p.y,
                           radius: aRadius,
                           xStart: pStart.x,
                           yStart: pStart.y,
                           xEnd: pEnd.x,
                           yEnd: pEnd.y});

  };

  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
  };

  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.stroke();

    this.currentPath_ = oldPath;
  };

  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
    var oldPath = this.currentPath_;
    this.beginPath();

    this.moveTo(aX, aY);
    this.lineTo(aX + aWidth, aY);
    this.lineTo(aX + aWidth, aY + aHeight);
    this.lineTo(aX, aY + aHeight);
    this.closePath();
    this.fill();

    this.currentPath_ = oldPath;
  };

  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
    var gradient = new CanvasGradient_('gradient');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    return gradient;
  };

  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                   aX1, aY1, aR1) {
    var gradient = new CanvasGradient_('gradientradial');
    gradient.x0_ = aX0;
    gradient.y0_ = aY0;
    gradient.r0_ = aR0;
    gradient.x1_ = aX1;
    gradient.y1_ = aY1;
    gradient.r1_ = aR1;
    return gradient;
  };

  contextPrototype.drawImage = function(image, var_args) {
    var dx, dy, dw, dh, sx, sy, sw, sh;

    // to find the original width we overide the width and height
    var oldRuntimeWidth = image.runtimeStyle.width;
    var oldRuntimeHeight = image.runtimeStyle.height;
    image.runtimeStyle.width = 'auto';
    image.runtimeStyle.height = 'auto';

    // get the original size
    var w = image.width;
    var h = image.height;

    // and remove overides
    image.runtimeStyle.width = oldRuntimeWidth;
    image.runtimeStyle.height = oldRuntimeHeight;

    if (arguments.length == 3) {
      dx = arguments[1];
      dy = arguments[2];
      sx = sy = 0;
      sw = dw = w;
      sh = dh = h;
    } else if (arguments.length == 5) {
      dx = arguments[1];
      dy = arguments[2];
      dw = arguments[3];
      dh = arguments[4];
      sx = sy = 0;
      sw = w;
      sh = h;
    } else if (arguments.length == 9) {
      sx = arguments[1];
      sy = arguments[2];
      sw = arguments[3];
      sh = arguments[4];
      dx = arguments[5];
      dy = arguments[6];
      dw = arguments[7];
      dh = arguments[8];
    } else {
      throw Error('Invalid number of arguments');
    }

    var d = this.getCoords_(dx, dy);

    var w2 = sw / 2;
    var h2 = sh / 2;

    var vmlStr = [];

    var W = 10;
    var H = 10;

    // For some reason that I've now forgotten, using divs didn't work
    vmlStr.push(' <g_vml_:group',
                ' coordsize="', Z * W, ',', Z * H, '"',
                ' coordorigin="0,0"' ,
                ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

    // If filters are necessary (rotation exists), create them
    // filters are bog-slow, so only create them if abbsolutely necessary
    // The following check doesn't account for skews (which don't exist
    // in the canvas spec (yet) anyway.

    if (this.m_[0][0] != 1 || this.m_[0][1]) {
      var filter = [];

      // Note the 12/21 reversal
      filter.push('M11=', this.m_[0][0], ',',
                  'M12=', this.m_[1][0], ',',
                  'M21=', this.m_[0][1], ',',
                  'M22=', this.m_[1][1], ',',
                  'Dx=', mr(d.x / Z), ',',
                  'Dy=', mr(d.y / Z), '');

      // Bounding box calculation (need to minimize displayed area so that
      // filters don't waste time on unused pixels.
      var max = d;
      var c2 = this.getCoords_(dx + dw, dy);
      var c3 = this.getCoords_(dx, dy + dh);
      var c4 = this.getCoords_(dx + dw, dy + dh);

      max.x = m.max(max.x, c2.x, c3.x, c4.x);
      max.y = m.max(max.y, c2.y, c3.y, c4.y);

      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                  filter.join(''), ", sizingmethod='clip');")
    } else {
      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
    }

    vmlStr.push(' ">' ,
                '<g_vml_:image src="', image.src, '"',
                ' style="width:', Z * dw, 'px;',
                ' height:', Z * dh, 'px;"',
                ' cropleft="', sx / w, '"',
                ' croptop="', sy / h, '"',
                ' cropright="', (w - sx - sw) / w, '"',
                ' cropbottom="', (h - sy - sh) / h, '"',
                ' />',
                '</g_vml_:group>');

    this.element_.insertAdjacentHTML('BeforeEnd',
                                    vmlStr.join(''));
  };

  contextPrototype.stroke = function(aFill) {
    var lineStr = [];
    var lineOpen = false;
    var a = processStyle(aFill ? this.fillStyle : this.strokeStyle);
    var color = a.color;
    var opacity = a.alpha * this.globalAlpha;

    var W = 10;
    var H = 10;

    lineStr.push('<g_vml_:shape',
                 ' filled="', !!aFill, '"',
                 ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                 ' coordorigin="0 0" coordsize="', Z * W, ' ', Z * H, '"',
                 ' stroked="', !aFill, '"',
                 ' path="');

    var newSeq = false;
    var min = {x: null, y: null};
    var max = {x: null, y: null};

    for (var i = 0; i < this.currentPath_.length; i++) {
      var p = this.currentPath_[i];
      var c;

      switch (p.type) {
        case 'moveTo':
          c = p;
          lineStr.push(' m ', mr(p.x), ',', mr(p.y));
          break;
        case 'lineTo':
          lineStr.push(' l ', mr(p.x), ',', mr(p.y));
          break;
        case 'close':
          lineStr.push(' x ');
          p = null;
          break;
        case 'bezierCurveTo':
          lineStr.push(' c ',
                       mr(p.cp1x), ',', mr(p.cp1y), ',',
                       mr(p.cp2x), ',', mr(p.cp2y), ',',
                       mr(p.x), ',', mr(p.y));
          break;
        case 'at':
        case 'wa':
          lineStr.push(' ', p.type, ' ',
                       mr(p.x - this.arcScaleX_ * p.radius), ',',
                       mr(p.y - this.arcScaleY_ * p.radius), ' ',
                       mr(p.x + this.arcScaleX_ * p.radius), ',',
                       mr(p.y + this.arcScaleY_ * p.radius), ' ',
                       mr(p.xStart), ',', mr(p.yStart), ' ',
                       mr(p.xEnd), ',', mr(p.yEnd));
          break;
      }


      // TODO: Following is broken for curves due to
      //       move to proper paths.

      // Figure out dimensions so we can do gradient fills
      // properly
      if (p) {
        if (min.x == null || p.x < min.x) {
          min.x = p.x;
        }
        if (max.x == null || p.x > max.x) {
          max.x = p.x;
        }
        if (min.y == null || p.y < min.y) {
          min.y = p.y;
        }
        if (max.y == null || p.y > max.y) {
          max.y = p.y;
        }
      }
    }
    lineStr.push(' ">');

    if (!aFill) {
      var lineWidth = this.lineScale_ * this.lineWidth;

      // VML cannot correctly render a line if the width is less than 1px.
      // In that case, we dilute the color to make the line look thinner.
      if (lineWidth < 1) {
        opacity *= lineWidth;
      }

      lineStr.push(
        '<g_vml_:stroke',
        ' opacity="', opacity, '"',
        ' joinstyle="', this.lineJoin, '"',
        ' miterlimit="', this.miterLimit, '"',
        ' endcap="', processLineCap(this.lineCap), '"',
        ' weight="', lineWidth, 'px"',
        ' color="', color, '" />'
      );
    } else if (typeof this.fillStyle == 'object') {
      var fillStyle = this.fillStyle;
      var angle = 0;
      var focus = {x: 0, y: 0};

      // additional offset
      var shift = 0;
      // scale factor for offset
      var expansion = 1;

      if (fillStyle.type_ == 'gradient') {
        var x0 = fillStyle.x0_ / this.arcScaleX_;
        var y0 = fillStyle.y0_ / this.arcScaleY_;
        var x1 = fillStyle.x1_ / this.arcScaleX_;
        var y1 = fillStyle.y1_ / this.arcScaleY_;
        var p0 = this.getCoords_(x0, y0);
        var p1 = this.getCoords_(x1, y1);
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;
        angle = Math.atan2(dx, dy) * 180 / Math.PI;

        // The angle should be a non-negative number.
        if (angle < 0) {
          angle += 360;
        }

        // Very small angles produce an unexpected result because they are
        // converted to a scientific notation string.
        if (angle < 1e-6) {
          angle = 0;
        }
      } else {
        var p0 = this.getCoords_(fillStyle.x0_, fillStyle.y0_);
        var width  = max.x - min.x;
        var height = max.y - min.y;
        focus = {
          x: (p0.x - min.x) / width,
          y: (p0.y - min.y) / height
        };

        width  /= this.arcScaleX_ * Z;
        height /= this.arcScaleY_ * Z;
        var dimension = m.max(width, height);
        shift = 2 * fillStyle.r0_ / dimension;
        expansion = 2 * fillStyle.r1_ / dimension - shift;
      }

      // We need to sort the color stops in ascending order by offset,
      // otherwise IE won't interpret it correctly.
      var stops = fillStyle.colors_;
      stops.sort(function(cs1, cs2) {
        return cs1.offset - cs2.offset;
      });

      var length = stops.length;
      var color1 = stops[0].color;
      var color2 = stops[length - 1].color;
      var opacity1 = stops[0].alpha * this.globalAlpha;
      var opacity2 = stops[length - 1].alpha * this.globalAlpha;

      var colors = [];
      for (var i = 0; i < length; i++) {
        var stop = stops[i];
        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
      }

      // When colors attribute is used, the meanings of opacity and o:opacity2
      // are reversed.
      lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                   ' method="none" focus="100%"',
                   ' color="', color1, '"',
                   ' color2="', color2, '"',
                   ' colors="', colors.join(','), '"',
                   ' opacity="', opacity2, '"',
                   ' g_o_:opacity2="', opacity1, '"',
                   ' angle="', angle, '"',
                   ' focusposition="', focus.x, ',', focus.y, '" />');
    } else {
      lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                   '" />');
    }

    lineStr.push('</g_vml_:shape>');

    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
  };

  contextPrototype.fill = function() {
    this.stroke(true);
  }

  contextPrototype.closePath = function() {
    this.currentPath_.push({type: 'close'});
  };

  /**
   * @private
   */
  contextPrototype.getCoords_ = function(aX, aY) {
    var m = this.m_;
    return {
      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
    }
  };

  contextPrototype.save = function() {
    var o = {};
    copyState(this, o);
    this.aStack_.push(o);
    this.mStack_.push(this.m_);
    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
  };

  contextPrototype.restore = function() {
    copyState(this.aStack_.pop(), this);
    this.m_ = this.mStack_.pop();
  };

  function matrixIsFinite(m) {
    for (var j = 0; j < 3; j++) {
      for (var k = 0; k < 2; k++) {
        if (!isFinite(m[j][k]) || isNaN(m[j][k])) {
          return false;
        }
      }
    }
    return true;
  }

  function setM(ctx, m, updateLineScale) {
    if (!matrixIsFinite(m)) {
      return;
    }
    ctx.m_ = m;

    if (updateLineScale) {
      // Get the line scale.
      // Determinant of this.m_ means how much the area is enlarged by the
      // transformation. So its square root can be used as a scale factor
      // for width.
      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
      ctx.lineScale_ = sqrt(abs(det));
    }
  }

  contextPrototype.translate = function(aX, aY) {
    var m1 = [
      [1,  0,  0],
      [0,  1,  0],
      [aX, aY, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.rotate = function(aRot) {
    var c = mc(aRot);
    var s = ms(aRot);

    var m1 = [
      [c,  s, 0],
      [-s, c, 0],
      [0,  0, 1]
    ];

    setM(this, matrixMultiply(m1, this.m_), false);
  };

  contextPrototype.scale = function(aX, aY) {
    this.arcScaleX_ *= aX;
    this.arcScaleY_ *= aY;
    var m1 = [
      [aX, 0,  0],
      [0,  aY, 0],
      [0,  0,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var m1 = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, matrixMultiply(m1, this.m_), true);
  };

  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
    var m = [
      [m11, m12, 0],
      [m21, m22, 0],
      [dx,  dy,  1]
    ];

    setM(this, m, true);
  };

  /******** STUBS ********/
  contextPrototype.clip = function() {
    // TODO: Implement
  };

  contextPrototype.arcTo = function() {
    // TODO: Implement
  };

  contextPrototype.createPattern = function() {
    return new CanvasPattern_;
  };

  // Gradient / Pattern Stubs
  function CanvasGradient_(aType) {
    this.type_ = aType;
    this.x0_ = 0;
    this.y0_ = 0;
    this.r0_ = 0;
    this.x1_ = 0;
    this.y1_ = 0;
    this.r1_ = 0;
    this.colors_ = [];
  }

  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
    aColor = processStyle(aColor);
    this.colors_.push({offset: aOffset,
                       color: aColor.color,
                       alpha: aColor.alpha});
  };

  function CanvasPattern_() {}

  // set up externs
  G_vmlCanvasManager = G_vmlCanvasManager_;
  CanvasRenderingContext2D = CanvasRenderingContext2D_;
  CanvasGradient = CanvasGradient_;
  CanvasPattern = CanvasPattern_;

})();

} // if


(function($){
	$('.module.followlist_categories').each(function () {
		var $this	= $(this);
		var params	= $this.data('jsparams');
		var eles	= {
			selected  : '',
			list_item : $this.find('.followlist_text'),


		};
		var functions = {
			follow_category : function (item) {
				var categories = [item.data('id')];
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'follow|category|'+item.data('id')]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: categories,
						type: 'Category'
					},
					error:function(data){},
					success:function(data){}
				});
			},
			unfollow_category : function (item) {
				var catid = [item.data('id')];
				var removing_fav = 'yes';
				_gaq.push(['_trackEvent', 'user_following', params.page_lmi, 'unfollow|category|'+item.data('id')]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_fav,
						ids: catid,
						type: 'Category'
					},
					error:function(data){},
					success:function(data){}
				});
			},
			handle_click : function(item) {
				if(item.hasClass('selected')) {
					item.removeClass('selected');
					item.empty();
					item.text('Follow');
					functions.unfollow_category(item);
				}
				else {
					item.addClass('selected');
					item.empty();
					item.text('Following');
					functions.follow_category(item);
				}
			},
		};

		$this.on('click','button.follow_button',function(ev){
			if(params.logged_in) {
				functions.handle_click($(this));
			}
			else
			{
				eles.selected = $(this);
				$(document).trigger("login_required");
			}
		});
		
		$this.on('click', 'a.login_required:not(.login_link):not(.signup_link)', function() {
			$(document).trigger('login_required');
		});

		$this.on('click', 'a.login_required.login_link', function() {
			$(document).trigger('login_required', 'login');
		});
		
		$this.on('click', 'a.login_required.signup_link', function() {
			$(document).trigger('login_required', 'signup');
		});
		
		$(document).on('login_successful',function(){
			if( eles.selected !== '' ) {
				functions.handle_click(eles.selected);
				eles.selected = '';
			}
		});

		$(document).ready(function() {
			eles.list_item.each(function() {
				if (this.offsetWidth < this.scrollWidth){
					$(this).attr('title', $(this).text());
				}
			});
		});

		$(document).on( 'login_failure', function(){
			eles.selected = '';
		});
	});
})(jQuery);


(function($) {
	$('.module.followlist_brands').each( function() {

		var $this = $(this);
		var params= $(this).data('jsparams');
		var eles = {
			$this		: $this,
			brandslist	: $this.find('.followlist'),
			brands		: $this.find('.followlist_item'),
			buttons   : $this.find('button'),
			config		: $this.data('jsparams'),
			count		: 0,
			selected	: '',
			login_link	: $this.find('.login_required.login_link'),
			signup_link	: $this.find('.login_required.signup_link')
		};

		var functions = {
			setup: function() {
				eles.count = Number(eles.config.count);
				eles.brands.slice( eles.count ).hide();
			},
			follow_brand: function(item) {
				var brand_id = [item.data('id')];
				_gaq.push(['_trackEvent', 'user_following', eles.config.page_lmi, 'follow|brand|'+brand_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						ids: brand_id,
						type: 'Brand'
					}
				});
			},
			unfollow_brand: function(item) {
				var brand_id = [item.data('id')];
				var removing_brand = 'yes';
				_gaq.push(['_trackEvent', 'user_following', eles.config.page_lmi, 'unfollow|brand|'+brand_id]);
				$.ajax({
					url: "/solo/user/following/dispatcher",
					data: {
						json: true,
						remove: removing_brand,
						ids: brand_id,
						type: 'Brand'
					}
				});
			},
			handle_click: function(item) {
				if(item.hasClass('selected')) {
					item.removeClass('selected');
					item.text('Follow');
					functions.unfollow_brand(item);
				}
				else {
					item.addClass('selected');
					item.text('Following');
					functions.follow_brand(item);
				}
			}
		};

		functions.setup();

		eles.login_link.on('click', function() {
			$(document).trigger("login_required", "login");
		});
		
		eles.signup_link.on('click', function() {
			$(document).trigger("login_required", "signup");
		});

		$(document).on('login_successful',function() {
			if( eles.selected !== '' ) {
				functions.handle_click(eles.selected);
				eles.selected = '';
			}
		});

		eles.buttons.on('click', function(ev) {
			if(!params.logged_in) {
				eles.selected = $(this);
				$(document).trigger("login_required");
			}
			else {
				eles.selected = '';
				functions.handle_click($(this));
			}
		});

		$(document).on('login_failure', function() {
			eles.selected = '';
		});
	});
})( jQuery );


var Base64 = {

	// private property
	_keyStr :"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

	// public method for encoding
	encode : function(input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;

		input = Base64._utf8_encode(input);

		while (i < input.length) {

			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);

			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;

			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}

			output = output + this._keyStr.charAt(enc1)
					+ this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3)
					+ this._keyStr.charAt(enc4);

		}

		return output;
	},

	// public method for decoding
	decode : function(input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;

		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

		while (i < input.length) {

			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));

			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;

			output = output + String.fromCharCode(chr1);

			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}

		}

		output = Base64._utf8_decode(output);

		return output;

	},

	// private method for UTF-8 encoding
	_utf8_encode : function(string) {
		string = string.replace(/\r\n/g, "\n");
		var utftext = "";

		for ( var n = 0; n < string.length; n++) {

			var c = string.charCodeAt(n);

			if (c < 128) {
				utftext += String.fromCharCode(c);
			} else if ((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			} else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}

		}

		return utftext;
	},

	// private method for UTF-8 decoding
	_utf8_decode : function(utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;

		while (i < utftext.length) {

			c = utftext.charCodeAt(i);

			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			} else if ((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i + 1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			} else {
				c2 = utftext.charCodeAt(i + 1);
				c3 = utftext.charCodeAt(i + 2);
				string += String.fromCharCode(((c & 15) << 12)
						| ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}

		}

		return string;
	}
};

function decode_redirect(str) {
	if(str!=null) {
		var u = Base64.decode(str);
		u = u.trim();
		if(u.indexOf("http")==0 || u.indexOf("/")==0)
		 	location.href=u;
		else
			location.href="http://www.answers.com";
		return false;
	}
}

var startOnClick = decode_redirect;

/**
 *  A simpler infinite scroll jquery plugin.
 */
        var infinite_scroll_timed_listen;
(function($){
 
    $.fn.infinitescrollmin = function(params) {

        var $this = $(this);
        var
            settings = $.extend({
                throttle_sec: 1000,
                trigger_px: 500,
                container: '.infinitescroll',
                nextlink: '.nextlink',
                append_to_uri: '',
                controller_class: 'scroll_control'
            },params),
            fetching = false,
            kill = false,
            throttled = false,
            scrolled = false,
            check_threshold = true,
            initial_bottom_threshold = 0,
            last_load_position = 0;

        var set_threshold = function(){
            initial_bottom_threshold = $(document).height() + 10;
            check_threshold = false;
        };

        var listen_next_results = function(){
            if (fetching || kill){
                return;
            }

            if( ( ($(document).height() <= initial_bottom_threshold) || ($(window).scrollTop() + $(window).height() > $(document).height() - settings.trigger_px) ) && $(window).scrollTop() != last_load_position) {
                fetch_next_results();
            }
        };

        var timed_listen_next_results = function(){
            if (check_threshold) {
                set_threshold();
            }

            if (kill){
                return;
            }

            if (scrolled === false) {
                infinite_scroll_timed_listen = setTimeout(function(){timed_listen_next_results();},settings.throttle_sec);
                return;
            }

            infinite_scroll_timed_listen = setTimeout(function(){timed_listen_next_results();},settings.throttle_sec);
            listen_next_results();
        };

        var fetch_next_results = function(){
            if(fetching||kill) return;
            fetching = true;
            var uri = $(settings.nextlink).last().attr("href")+settings.append_to_uri;
            if(uri) {
                $this.append('<div asg-loading class="loading"></div>');
                $("<div>").load(uri,function(){
                    track_pageview();
                    var html = $(settings.container,this).html();
                    if( html === '' || typeof html === 'undefined' || !more_infinity(html) ) {
                        kill = true;
                    }
                    else {
                        $this.append(html);
                        $(document).trigger("js_infinite_new_content");
                    }
                    $(settings.nextlink).hide();
                    fetching = false;
                    throttled = false;
                    $this.find("div.loading").remove();
                    last_load_position = $(window).scrollTop();
                });
            }
            else {
                kill = true;
                fetching = false;
            }
        };

        // because the html we are looking in always
        // returns at least the module controlling
        // the scroll, this method loops through all
        // the divs in returned html, sees if they
        // are a module that doesn't have the class
        // scroll_control and assumes this means we
        // got valid content. for this to work,
        // add the controllers class to your
        // controller module and make sure no other
        // modules renders in the return when scroll
        // is done.
        var more_infinity = function(html){
            if(kill){
                return false;
            }
            // wrapping since jquery ignores the outer most wrapper
            html = "<div>" + html + "</div>";
            got_results = false;
            $("div.module",html).each(function(){
                if(!$(this).hasClass(settings.controller_class)){
                    got_results = true;
                }
            });
            return got_results;
        };

        var throttle = function(method){
            if(throttled) return;
            throttled = true;
            method();
            setTimeout(function(){throttled=false;},settings.throttle_sec);
        };

        var track_pageview = function(){
            // GA
            try {
                if(typeof _gaq !== 'undefined'){
                    // pageview
                    _gaq.push(['_trackPageview', window.location.href]);
                    // infinite_scroll event
                    _gaq.push(['_trackEvent', 'infinite_scroll', '1']);
                }
            }
            catch(e) {}
            // Quantcast
            try {
                if(typeof __qc !== 'undefined'){
                    __qc.qpixelsent = [];
                    _qevents.push({qacct: __qc.qopts.qacct});
                    __qc.firepixels();
                }
            }
            catch(e) {}
            // Comscore
            try {
                if(typeof COMSCORE !== 'undefined') {
                    COMSCORE.beacon({c1: "2", c2: "6035968"});
                }
            }
            catch(e) {}
        };

        $(settings.nextlink).hide();

        $(document).ready(function(){timed_listen_next_results();});

        $(window).one('scroll.infinite', function(){scrolled = true;});

        return this;
    };

}(jQuery));

(function($){
	$(document).ready(function(){
		$this = $(".module.feedcards_scroll");
		var params = $this.data('jsparams');
		$(params.container).infinitescrollmin(params);
	});
})(jQuery);

var category_selector_link = function(category_selector_link_parameters) {
	this.init = function() {
		// This module should launch the category popup only if link is clicked
		$(".catp_selector").click(function(){
			catselector.open_category_selector(category_selector_link_parameters.selector_link);
		});
		// Auto-load the pop-up when the page loads - It has to load only if the user is logged in
		if( (category_selector_link_parameters.newqpage || category_selector_link_parameters.newqAdded) && category_selector_link_parameters.user_logged_in ) {
			catselector.open_category_selector(category_selector_link_parameters.thank_you_link);
		}
	};

	this.open_category_selector = function(link){
		$.facebox({
			ajax: link
		});
	};

	var catselector = this;
	catselector.init();
};
category_selector_link(category_selector_link_parameters);


var links_question = (function(){

	//private
	var elements = {
		links_question_more:$('.links_question .links_question_more'),
		show_hide_link:$('.links_question .show_hide')
	};

	var toggle_bool = false;

	var show_hide_events = {

		show_hide_click:function(){

			if (toggle_bool === true)
			{
				toggle_bool = false;
				collapse();
			}
			else
			{
				toggle_bool = true;
				expand();
			}

			function expand(){

				elements.links_question_more.slideToggle('slow');
		    	elements.show_hide_link.html('<a class="less">Less  <i class="fa fa-angle-up"></i></a>');
		    };

		    function collapse(){

		    	elements.links_question_more.slideToggle('slow');
		    	elements.show_hide_link.html('<a class="more">More  <i class="fa fa-angle-down"></i></a>');
		    }
		}
	};

	// initialize
	return {

		init:function(){

			elements.links_question_more.hide();
			elements.show_hide_link.bind('click', show_hide_events.show_hide_click)
		}
	};

})();

links_question.init();




(function ($) {
	$('.links_site').each(function () {
		var $_this = $(this),
		menu_toggle = $_this.find('.is_parent');

		menu_toggle.each(function () {
			var $_this = $(this);

			$_this.on('click', function () {
				var $_this = $(this),
						$icon = $(this).find('.fa');

				$_this.toggleClass('children_hidden');

				if ($_this.hasClass('children_hidden') === true) {
					$icon.removeClass('fa-angle-down').addClass('fa-angle-right');
				} else {
					$icon.removeClass('fa-angle-right').addClass('fa-angle-down');
				}
			})
		});
	});
})(jQuery);


(function($, window, document, undefined){
    'use strict';

    //----------------------------------------------------------------------
    // DATA
    //----------------------------------------------------------------------

        // dummy value used for either timed event count or slide event count 
        // depending on which custom tracking variable we are sending in an analytics
        // request
    var DUMMY_COUNT_VALUE = 9999999,

        // Wait to allow page load and other routines before running auto-refresh code
        throttle_refresh = true,
        throttle_refresh_time = 250,    // how long
        throttle_refresh_done = false;  // flag when finished

    //----------------------------------------------------------------------
    // LOCALIZED FUNCTIONS
    //----------------------------------------------------------------------

    function getTimeStamp(){
        var a = new Date();
        var b = a.getFullYear() + "-" 
              + (a.getMonth()+1) + "-" 
              + a.getDate() + " "
              + a.getHours() + ":" + a.getMinutes() + ":" + a.getSeconds();

        return escape(b);
    }

    function getTimezone(){
        return ((new Date().getTimezoneOffset() / 60) * (-1));
    }

    /**
     * Return a random number between min/max where the mean
     * result is approximately the mode across a uniform distribution.
     * @param min {Number} - lower limit of range (inclusive)
     * @param max {Number} - upper limit of range (inclusive)
     * @return {Function} - a function that returns a random number between 'min' and 'max'
     */
    var makeIntervalFunction = function(min, max) {
        return function() {
            var seconds = Math.round(Math.random() * (max - min)) + min;
            // console.log("[debug] makeIntervalFunction() --> generated new interval of %d seconds", seconds);
            return (seconds * 1000);    // return 'ms'
        };
    };


    // REFRESH ROUTINES FOR DFP AND THIRD-PARTY //

    /**
     * Refresh DFP Ads (handled by Google DFP services)
     */
    function refresh_dfp() { 
        if (window['googletag'] && googletag.cmd) {
            googletag.cmd.push(function() {
                googletag.pubads().refresh();
            });
        }
    }

    /**
     * Refresh Third Party Ads (handled by external HTML module on page)
     */
    function refresh_third_party(delay){
        // DEBUG: remove later, wait on refreshes for content loading
        if (delay) {
            setTimeout(function() {
                $(document).trigger("third_party_reload");
            }, delay);
        }
        else {
            $(document).trigger("third_party_reload");
        }
    }

    // UTILITY ROUTINES //


    // RESET PRE-PING ROUTINES //

    /** 
     * Resets OpenX related globals  
     */
    function reset_openx() {
        if(typeof window.ox_dfp_key_value !== 'undefined')
        {
            googletag.cmd.push(function(){
                for(var index in ox_dfp_key_value) {
                    googletag.pubads().setTargeting(index, "0");
                    }
            });
        }
        window.ox_dfp_key_value = {};
    }

    /** 
     * Resets Amazon related globals
     */
    function reset_amazon() {
        window.amzn_ads = {};
        if(typeof document.amzn_slots !== 'undefined')
        {
            var am_slots = document.amzn_slots;
            document.amzn_slots = {};
        }

        if (typeof am_slots !== 'undefined'){
            if(window['googletag'] && googletag.cmd){
                googletag.cmd.push(function(){
                    for(var index in am_slots)
                    {
                        googletag.pubads().setTargeting(am_slots[index], "0");
                    }
                });
            }
        }
        return;
    }

    /**
     * Resets Pubmatic related globals
     */
    function reset_pubmatic() {
        window.pub_bid = 0;
        window.pub_creative = '';
        window.pub_tracking = '';
        if (window['googletag'] && googletag.cmd) {
            googletag.cmd.push(function() {
                googletag.pubads().setTargeting("pub300x250", round(pub_bid));
            });
        }
        return;
    }

    // -----------------
    // New Casale bidder
    // -----------------
    function new_casale_reset() {
        return;
    }
    // Rebid Casale ads
    function new_casale_rebidder() {
        index_start_ht();
    }

    // -----------------
    // Old Casale bidder
    // -----------------
    /**
     * Resets Casale related globals
     */
    function reset_casale() {
        var cas_slots;

        window._IndexRequestData = {};

        if (window['index_slots']) {
            cas_slots = index_slots;
            window.index_slots = {};
        }

        if (typeof cas_slots !== 'undefined') {
            if (window['googletag'] && googletag.cmd) {
                googletag.cmd.push(function() {
                    for(var index in cas_slots) {
                        var slot_info = cas_slots[index].split('price');
                        if (typeof slot_info[0] !== 'undefined' && slot_info[0] !== '') {
                            googletag.pubads().setTargeting(slot_info[0], "0");
                        }
                    }
                });
            }
        }
        return;
    }

    // RELOAD ROUTINES FOR EACH AD SERVICE //

    function reload_casale() {
        var id = (new Date().getTime())+Math.floor(Math.random() * 1000) + 1000,
            iframe = document.createElement("iframe");

        $('iframe#casale-bid-reload-frame').remove();

        window.casale_callbacks = window.casale_callbacks || {};

        iframe.width = 0;
        iframe.height = 0;
        iframe.marginheight=0;
        iframe.marginwidth=0;
        iframe.frameborder=0;
        iframe.scrolling="no";
        iframe.id = 'casale-bid-reload-frame';
        iframe.src = 'javascript:' +
            '\'<!DOCTYPE html><html><body leftMargin="0" topMargin="0" marginwidth="0" marginheight="0">' +
            '<scr' + 'ipt>' +
                'window["IndexArgs"] = {"siteID":151555, "slots":[{"id":"ca300x250","width":300,"height":250},' +
                            '{"id":"ca728x90","width":728,"height":90}, {"id":"ca728x90-2","width":728, "height":90},{"id":"ca160x600", "width":160, "height": 600}]};' +
            '</scr' + 'ipt>' +
            '<scr' + 'ipt src="//js.indexww.com/apl/apl.js"></scr' + 'ipt>' +
            '<scr' + 'ipt>' +
                'top.index_slots = window["index_slots"];top._IndexRequestData = window["_IndexRequestData"];' +
                'if (top["casale_callbacks"] && top.casale_callbacks["'+id+'"]) {' +
                    'top.casale_callbacks["'+id+'"](window["index_slots"]);' +
                    'delete(top.casale_callbacks["' + id + '"]);' +
                '}' +
            '</scr' + 'ipt>' +
            '</body></html>\'';

        window.casale_callbacks[id] = function(){
            if(typeof index_slots !== 'undefined' && index_slots.length) {
                googletag.cmd.push(function(){
                    for(var index in index_slots) {
                        var slot_info = index_slots[index].split('price');
                        var casale_key = slot_info[0];
                        var casale_value;
                        if(typeof slot_info[1] !== 'undefined') {
                            casale_value = slot_info[1]/100;
                        }
                        if((typeof casale_key !== 'undefined' && casale_key !== '') && (typeof casale_value !== 'undefined' && casale_value !== '')) {
                            googletag.pubads().setTargeting(casale_key, casale_value.toFixed(2));
                        }
                    }
                });
            }
        };

        document.body.appendChild(iframe);
    }

    function reload_openx(ox_ad_unit_sizes) {
        if (typeof OX == "undefined") {
            var head = document.getElementsByTagName('head').item(0);
            var script = document.createElement('script');
            script.setAttribute('type', 'text/javascript');
            script.setAttribute('src', 'http://ox-d.answers.servedbyopenx.com/w/1.0/jstag');
            head.appendChild(script);
        }
        var ox_rev = 0;
        if (typeof OX !== "undefined") {
            var x = OX();
            x.addPage("16156");
            x.addHook(function(adResponse) {
                var units = ox_ad_unit_sizes; // ad unit IDs.
                for (i = 0; i < units.length; i++)
                {
					adunit = adResponse.getOrCreateAdUnit(units[i]);
                    if(typeof adunit !== "undefined") {
                        var pub_rev = adunit.get("pub_rev");
                    }
                    if(typeof pub_rev !== "undefined") {
                        ox_rev = (pub_rev / 1000);
                    }
                    else {
                        ox_rev = 0;
                    }
                    if(typeof adunit !== 'undefined' && ox_rev > 0) {
                        if(units[i] == 562080)
						{
							ox_dfp_key_value["ox"+adunit.get("width")+"x"+adunit.get("height") + "-2"] = round(ox_rev);
						}
						else
						{
							ox_dfp_key_value["ox"+adunit.get("width")+"x"+adunit.get("height")] = round(ox_rev);
						}
                    }
					pub_rev = undefined;
					adunit = undefined;
                }
                OX_520ab22764323 = {};
                OX_520ab22764323 = x;

                googletag.cmd.push(function(){
                    for(var index in ox_dfp_key_value) {
                        googletag.pubads().setTargeting(index, ox_dfp_key_value[index]);
                    }
                });

            }, OX.Hooks.ON_AD_RESPONSE);

            x.load();
        }
    }

    function reload_pubmatic() {
        try {
            var timezone=getTimezone();
            var timestamp=getTimeStamp();
            var randomnumber=((Math.random()*11)/10);
            var pubId=36185;
            var siteId=36186;
            var kadId=59138;
            var kadwidth=300;
            var kadheight=250;
            var adURL="http://showads.pubmatic.com/AdServer/AdServerServlet?pubId="+pubId+"&siteId="+siteId+"&adId="+kadId+"&kadwidth="+kadwidth+"&kadheight="+kadheight+"&SAVersion=2&js=1&pageURL=http%3A%2F%2Fwiki.answers.com&inIframe=0&operId=102&kltstamp="+timestamp+"&timezone="+timezone+"&ranreq="+randomnumber+"&rs=2";

            $('#pubAddedScript').remove();

            var head = document.getElementsByTagName('head').item(0);
            var script = document.createElement('script');

            script.setAttribute('id', 'pubAddedScript');
            script.setAttribute('type', 'text/javascript');
            script.onload = script.onreadystatechange = function() {
                if (!script.readyState || script.readyState === 'complete' || script.readyState === 'loaded') {
                    script.onload = script.onreadystatechange = "";
                    googletag.cmd.push(function() {
                        googletag.pubads().setTargeting("pub300x250",round(pub_bid));
                    });
                }
            };
            script.onerror = function() {
                googletag.cmd.push(function() {
                    googletag.pubads().setTargeting("pub300x250","0");
                });
            };
            script.setAttribute('src', adURL);
            head.appendChild(script);
        }
        catch(e) {
            googletag.cmd.push(function() {
                googletag.pubads().setTargeting("pub300x250","0");
            });
        }
    }

    function reload_amazon()
    {
        var aax_src='3020';
        var url = encodeURIComponent(document.location);
        try {
            url = encodeURIComponent("" + window.top.location);
        }
        catch(e) {
            // What now?
        }

        var amzAdUrl = 'http://aax-us-east.amazon-adsystem.com/e/dtb/bid?src=' + aax_src + '&u=' +url+'&cb=' + Math.round(Math.random()*10000000);

        $('#amznTag').remove();

        var head = document.getElementsByTagName('head').item(0);
        var script = document.createElement('script');

        script.setAttribute('type', 'text/javascript');
        script.setAttribute('id', 'amznTag');
        script.onload = script.onreadystatechange = function() {
            if (!script.readyState || script.readyState === 'complete' || script.readyState === 'loaded') {
                script.onload = script.onreadystatechange = "";
                if (typeof document.amzn_slots !== 'undefined') {
                    googletag.cmd.push(function(){
                        for (var index in document.amzn_slots) {
                            googletag.pubads().setTargeting(document.amzn_slots[index], "1");
                        }
                    });
                }
            }
        };

        script.setAttribute('src', amzAdUrl);

        head.appendChild(script);
    }


    //----------------------------------------------------------------------
    // MODULE INSTANCE SETUP
    //----------------------------------------------------------------------

    // Setup instance for each module on the page (in this case there,... there can be only one!)
    $('.ads_refresher').each(function(){

        // console.log("[debug] jsparams = %o", JSON.parse($(this).attr('data-jsparams')));

        var $this = $(this),


            // JSParams from logic file
            jsparams = JSON.parse($this.attr('data-jsparams')),

            // empty function
            noop = function(){},


            // Module configuration
            config = {
                'ad_refresh_delay_time':    (!jsparams.ad_refresh_delay_time || jsparams.ad_refresh_delay_time == "") ? undefined : jsparams.ad_refresh_delay_time,
                'dfp_timer_refresh_interval':  jsparams.dfp_timer_refresh_interval, 

                // Third Party: Use auomatically generated interval timers based on a range
                'use_third_party_autotimed_refresh': jsparams.use_third_party_autotimed_refresh,        // random timer refresh interval based on range?
                'third_party_autotimed_refresh_range': jsparams.third_party_autotimed_refresh_range,    // range, [min, max] array

                // DFP: Use auomatically generated interval timers based on a range
                'use_dfp_autotimed_refresh': jsparams.use_dfp_autotimed_refresh,        // random timer refresh interval based on range?
                'dfp_autotimed_refresh_range': jsparams.dfp_autotimed_refresh_range,    // range, [min, max] array

                // Third Party ad refreshing (using exact, set timed interval specified in config)
                'use_third_party_timed_refresh':     jsparams.use_third_party_timed_refresh, // use timed refreshes at all?
                'third_party_refresh_interval':      jsparams.third_party_refresh_interval, //this is used for the refresh in the 3rd party ads
                'max_third_party_consecutive_timed': jsparams.max_third_party_consecutive_timed, //this is for the max # of times for third party to refresh for the timed refresh

                // DFP ad refreshing
                'use_dfp_timed_refresh':     jsparams.use_dfp_timed_refresh, // use timed refreshes at all?
                'dfp_refresh_interval':      jsparams.dfp_refresh_interval, //this is used for the dfp timed refresh with pre-ping
                'max_dfp_consecutive_timed': jsparams.max_dfp_consecutive_timed, //this is for the max # of times for dfp to refresh for the timed refresh

                // click threshold for when to start Amazon rebidding
                'amazon_refresh_start':        jsparams.amazon_refresh_start, 

                // start refresh timers on page load
                'refresh_timers_start_on_pageload': jsparams.refresh_timers_start_on_pageload,

                // custom analytics tracking variable names
                'refresh_counter_custom_variable':       jsparams.refresh_counter_custom_variable,
                'timed_refresh_counter_custom_variable': jsparams.timed_refresh_counter_custom_variable,

                // Refresh on every nth 'click' events as well as via any timers
                'refresh_on_every_nth_click': jsparams.refresh_on_every_nth_click,

                // ads to reset/rebid
                'reload_pub_bid':   jsparams.reload_pub_bid,
                'reload_amz_bid':   jsparams.reload_amz_bid,
                'reload_cas_bid':   jsparams.reload_cas_bid,
                'reload_openx_bid': jsparams.reload_openx_bid,

                // total number of reloads requested
                'reload_requests':  jsparams.reload_pub_bid + jsparams.reload_amz_bid + jsparams.reload_cas_bid + jsparams.reload_openx_bid,

                // what events (slideshow or other) should we respond to for refresh?
                'refresh_event_list': jsparams.refresh_event_list.split(/\s*,\s*/),

				//this is the openx ad units, down and dirty method, just having units typed in
				//separated by commas, can be changed at later date
				'openx_ad_unit_sizes': jsparams.openx_ad_unit_sizes
            },

            // Reset/Rebid configuration
            ads_config = {
                // PubMatic Ads
                'pub':   { 
                    reset_fn: reset_pubmatic,
                    rebid_fn: reload_pubmatic, 
                    reload_bid: jsparams.reload_pub_bid
                }, 
                // Amazon
                'amz':   { 
                    reset_fn: reset_amazon,
                    rebid_fn: reload_amazon, 
                    reload_bid: jsparams.reload_amz_bid
                },
                // Casale
                'cas':   { 
                    reset_fn: (jsparams.new_cas_bidder ? new_casale_reset : reset_casale),
                    rebid_fn: (jsparams.new_cas_bidder ? new_casale_rebidder : reload_casale), 
                    reload_bid: jsparams.reload_cas_bid || jsparams.new_cas_bidder
                },
                // OpenX
                'openx': { 
                    reset_fn: reset_openx,
                    rebid_fn: reload_openx, 
                    reload_bid: jsparams.reload_openx_bid
                }
            };

        // console.log("[debug] config=%o", config);

        /**
         * Specific functions to get an autogenerated, random interval for
         * both DFP and Third Party based on the config parameters passed in.
         * @return {Function} a function that returns a random interval in milliseconds
         */
        var getThirdPartyAutoInterval = (function() {
            if (config.use_third_party_autotimed_refresh) {
                var min = config.third_party_autotimed_refresh_range[0],
                    max = config.third_party_autotimed_refresh_range[1];

                // console.log("[debug] Third-Party is auto generating intervals between (%d, %d)", min, max);
                return makeIntervalFunction(min, max);
            }
            else {
                return noop;
            }
        })();

        var getDFPAutoInterval = (function() {
            if (config.use_dfp_autotimed_refresh) {
                // console.log("[debug] config.dfp_autotimed_refresh_range = %o", config.dfp_autotimed_refresh_range);
                var min = config.dfp_autotimed_refresh_range[0],
                    max = config.dfp_autotimed_refresh_range[1];

                // console.log("[debug] DFP is auto generating intervals between (%d, %d)", min, max);
                return makeIntervalFunction(min, max);
            }
            else {
                return noop;
            }
        })();

        /**
        * Sets up custom targeting variables for tracking in analytics.
        * @param ev {string} - the event type we're tracking 'click', 'timed'
        */
        var set_tracking_target_counts = (function() {
            // keep track of calls over time for each type of event
            var counters = {
                'click': 0,
                'timed': 0
            },
            // Analytics custom variable names for targeting
            click_var_name = config.refresh_counter_custom_variable.toString(),
            timed_var_name = config.timed_refresh_counter_custom_variable.toString();

            return function(ev) {
                counters[ev]++;
                var click_val = (ev == 'click') ? counters['click'] : DUMMY_COUNT_VALUE,
                    timed_val = (ev == 'timed') ? counters['timed'] : DUMMY_COUNT_VALUE;

                if (window['googletag'] && googletag.cmd) {
                    googletag.cmd.push(function() {
                        googletag.pubads().setTargeting(click_var_name, click_val.toString());
                        googletag.pubads().setTargeting(timed_var_name, timed_val.toString());
                    });
                }
                // return a reference to current counters
                return counters;
            };
        })();


        function rebid_and_refresh_dfp(evt, delay) {
            var amazon_click_start = config.amazon_refresh_start,
                counters,
                rebid_and_refresh = function() {
                    // set analytics tracking target counts 
                    counters = set_tracking_target_counts(evt);

                    // handle any rebid requests
                    for (var service in ads_config) {
                        var ad = ads_config[service];
                        // reset (pre ping) and reload bid values for service
                        if (ad.reload_bid) {
                            if (service == 'amz' && counters.click >= amazon_click_start) {
                                // Only rebid on amazon based on above condition
                                ad.reset_fn();   
                                ad.rebid_fn();   
                            }
                            else if(service == 'openx'){
                                ad.reset_fn();   
                                ad.rebid_fn(config.openx_ad_unit_sizes);   
                            }
                            else
                            {
                                ad.reset_fn();   
                                ad.rebid_fn();   
                            }
                        }
                    }

                    // refresh DFP ads
                    // console.log("[debug] refreshing DFP ads now");
                    refresh_dfp();
                };

            if (delay) {
                // DEBUG: remove later, wait on refreshes for content loading
                setTimeout(rebid_and_refresh, delay);
            }
            else {
                rebid_and_refresh();
            }
        }

        /**
         * Creates and runs a refresh timer routine for the given
         * ad service passed in. 
         */
        var run_dfp_refresh = (function() {
            var count = 0,
                interval = (config.use_dfp_autotimed_refresh) ? false : config.dfp_refresh_interval,
                max_count = config.max_dfp_consecutive_timed,
                delay = config.ad_refresh_delay_time || false,
                timer;

            return function _timer(evt, reset) {
                evt || (evt = 'timed');     // default to timed event
                reset || (reset = false);   // run again, reseting counters

                // console.log("[debug] run_dfp_refresh(%s, %s)", evt, reset);
                if (evt == 'timed' && (!config.use_dfp_timed_refresh && !config.use_dfp_autotimed_refresh) ) {
                    // no timed refreshes were requested in config
                    return;
                }

                if (reset) {
                    // a reset should stop current timer prior to creating a new one
                    window.clearTimeout(timer); 
                    count = 0;
                }

                if (evt == 'click') {
                    // call immediately for clicks, no timer
                    rebid_and_refresh_dfp(evt, delay);
                }
                else /* evt == 'timed' */ {
                    var _interval = interval || getDFPAutoInterval();
                    // console.log("[debug] -> interval=%s", _interval);
                    timer = window.setTimeout(function () {
                        count++;
                    
                        rebid_and_refresh_dfp(evt, delay);

                        if (count < max_count) { 
                            // call ourself again after refresh interval
                            timer = window.setTimeout(function() { _timer(evt); }, _interval);
                        }
                        else {
                            // timer is done
                            window.clearTimeout(timer);
                            count = 0;
                        }
                    }, _interval);
                }
            };
        })();

        var run_third_party_refresh = (function() {
            var count = 0,
                interval = (config.use_third_party_autotimed_refresh) ? false : config.third_party_refresh_interval,
                max_count = config.max_third_party_consecutive_timed,
                delay = config.ad_refresh_delay_time || false,
                timer;

            return function _timer(evt, reset) {
                evt || (evt = 'timed');     // default to timed event
                reset || (reset = false);   // run again, reseting counters

                // console.log("[debug] run_third_party_refresh(%s, %s)", evt, reset);
                if (evt == 'timed' && (!config.use_third_party_timed_refresh && !config.use_third_party_autotimed_refresh)) {
                    // no timed refreshes were requested in config
                    return;
                }

                if (reset) {
                    // a reset should stop current timer prior to creating a new one
                    window.clearTimeout(timer); 
                    count = 0;
                }

                if (evt == 'click') {
                    // call immediately for clicks, no timer
                    refresh_third_party(evt, delay);
                }
                else if (evt == 'timed') {
                    var _interval = interval || getThirdPartyAutoInterval();
                    // console.log("[debug] -> interval=%s", _interval);
                    timer = window.setTimeout(function() {
                        count++;
                        
                        // refresh 3rd-party ads
                        refresh_third_party(evt, delay);

                        if (count < max_count) {
                            // call ourself again after refresh interval
                            timer = window.setTimeout(function() { _timer(evt); }, _interval);
                        }
                        else {
                            // timer is done
                            window.clearTimeout(timer);
                            count = 0;
                        }
                    }, _interval); 
                }
            };
        })();


        // START RUNNING //
        
        // avoid refresh on pageload, when slideshow changes page/hash
        if (throttle_refresh) {
            window.setTimeout(function(){
                throttle_refresh_done = true;
            }, throttle_refresh_time);
        }
        else {
            throttle_refresh_done = true;
        }

        // Start timers on page load?
        if (config.refresh_timers_start_on_pageload) {
            // Run refresh code for each configured ad service on page load
            run_dfp_refresh('timed');
            run_third_party_refresh('timed');
        }

        $(document).unbind("dfpslot_refresh");    

        // when requested, refresh all DFP and third-party ads 
        $(document).bind("dfpslot_refresh", function(){ 
            run_dfp_refresh('timed');
            run_third_party_refresh('timed');
        });

        // NOTE:  the ad_refresh event is triggered on next/prev  click by slideshow
        // if using with a different slideshow, consider attaching to slidenext/slideprev events
        // instead.
        $(document).bind(config.refresh_event_list.join(" "), (function(){ 
            var count = 0,
                timers_started = !!config.refresh_timers_start_on_pageload;

            return function(ev) {
                count++;
                if ((count % config.refresh_on_every_nth_click) == 0) {
                    // run refresh immediately on these clicks
                    run_dfp_refresh('click');
                    run_third_party_refresh('click');

                    // ensure timed refreshes are kicked reset on click 
                    run_dfp_refresh('timed', true);
                    run_third_party_refresh('timed', true);
                    timers_started = true;
                }

                // First click sets off timed refresh events (if we didn't do it on page load)
                if (count == 1 && !config.refresh_timers_start_on_pageload && !timers_started) { 
                    run_dfp_refresh('timed');
                    run_third_party_refresh('timed');
                }
            };
         })()); 
    });

})(jQuery, window, document);


function callTacoda(){
	if ("ra" != jwgData.metrics.tacodaType && "wa" != jwgData.metrics.tacodaType) {
		return;
	}
	var ref = "";
	if (document.referrer) {
		ref = "&tacref=" + encodeURIComponent(document.referrer);
	}
	var query;
	if (typeof jwgData != "undefined") {
		query = getHash("q");
	} 
	if (typeof query == "undefined") {
		var jQueryPageTitle = jQuery("#pageTitle");
		if (jQueryPageTitle.length != 0) {
			query = jQuery("#pageTitle").html();
		} else {
			query = "";
		}
	}
	query = "&query=" + encodeURIComponent(query);
	jQuery("body").append('<iframe id="tacoda" width=1 height=1 frameborder=0 src="' + jwgData.config.wgServer + '/resources/tac.html?site=' + jwgData.metrics.tacodaType + query + ref + '"></iframe>');
}

if (jwgData.metrics.tacodaType) 
{	
	$(window).load(function(){
		setTimeout(callTacoda, 2000);
	});
}


if( typeof jQuery !== 'undefined' ) {
    jQuery(document).ready(function() {
        jQuery.each(jsparams_objects, function(module_name, module_object) {
            jQuery(".js-"+module_name).each(function() {
                var module = this;
                var module_instance = new module_object();
                // Use .attr insstead of .data because apparently we still have jQuery 1.4.2 in the wild.
                var json = jQuery( module ).attr("data-jsparams");
                // Use browser-native JSON if available or fallback to jQuery (only works with 1.4.1+)
                var params = ((typeof JSON !== 'undefined') && JSON.parse(json)) || jQuery.parseJSON(json);
                jQuery.each(params, function(param, value) {
                    module_instance[param] = value;
                });
                module_instance.init(module, new rubix_log(module_name));
            });
        });
    });

    // Client Component handling
    if (window['flight'] !== undefined 
    && window['__components__'] !== undefined
    && __components__.length) {
        var len = __components__.length, comp;
        for (var i=0; i < len; i++) {
            comp = __components__[i];
            if (comp.attach_on_page_load) {
                var config = comp.config;
                delete config.is_component; // not needed
                // pass useful component info as '_component' attribute
                config._component = {
                    name: comp.name,
                    id: comp.id,
                    attach_on_page_load: comp.attach_on_page_load
                };
                window[comp.name].attachTo(comp.node, config);
            }
        }
    }

    (function() {
            // get our domain name
        var origin = window.location.hostname.replace(/:*$/,''),
            // how long to wait for DOM ready to fire
            WAIT_ON_DOM = 1000;

        // ensure we can push a GA event (does nothing if analytics not on the page)
        window['_gaq'] || (window['_gaq'] = []);

        // Keep rogue scripts using sockets from stalling content loaded event
        window.setTimeout(function() {
            if (!jQuery.isReady) {
                _gaq.push(['_trackEvent', 'Warning', origin, 'manual_content_loaded', null, true]);
                jQuery.ready();
            }
        }, WAIT_ON_DOM);

        // Handle rogue scripts trying to document.write, stub document.write()
        document.write = function() {
            // non-interactive event showing rogue doc write action
            _gaq.push(['_trackEvent', 'Warning', origin, 'write_after_render', null, true]);
        };
        document.writeln = function() {
            // non-interactive event showing rogue doc writeln action
            _gaq.push(['_trackEvent', 'Warning', origin, 'writeln_after_render', null, true]);
        };
        document.open = function() {
            // non-interactive event showing rogue open write action
            _gaq.push(['_trackEvent', 'Warning', origin, 'open_after_render', null, true]);
        };
    })();
}
